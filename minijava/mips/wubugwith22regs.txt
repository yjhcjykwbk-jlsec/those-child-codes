//
// Generated by JTB 1.3.2
//
package visitor;
import syntaxtree1.*;
import java.util.*;
import java.util.Map.Entry;

import visitor.st;

class Period {
	int start, end;
	public Period(int a, int b) 
	{
		start = a;
		end = b;
	}
}
class AlivePeriod {
	Vector<Period> periods;
	Vector<Integer> defPoints;
	Vector<Integer> usePoints;
	public AlivePeriod() {
		periods = new Vector<Period>(5);
		defPoints = new Vector<Integer>(2);
		usePoints = new Vector<Integer>(5);
	}
	public Period getP(int i) {
		return periods.elementAt(i);
	}
	public void putP(int a, int b) {
		periods.add(new Period(a, b));
	}
	public int getD(int a) {
		return defPoints.elementAt(a);
	}
	public void putD(int a) {
		defPoints.add(a);
	}
	public int getU(int a) {
		return usePoints.elementAt(a);
	}
	public void putU(int a) {
		usePoints.add(a);
	}
	public boolean overLap(AlivePeriod other) {
		int j = 0, sizej = other.periods.size();
		int i = 0, sizei = this.periods.size();
		Period a, b;
		while (true) 
		{
			if (j >= sizej || i >= sizei)
				break;
			a = this.getP(i);
			b = other.getP(j);
			if (a.end < b.start)
				i++;
			else if (b.end < a.start)
				j++;
			else
				return true;
		}
		int sizej1=other.defPoints.size();
		int sizei1=defPoints.size();
		i=0;j=0;
		int c,d;
		while (true) 
		{
			if (j >= sizej || i >= sizei1)
				break;
			c=getD(i);
			b=other.getP(j);
			if(c<b.start) i++;
			else if(c>=b.end) j++;
			else return true;
		}
		i=0;j=0;
		while (true) 
		{
			if (i >= sizei || j >= sizej1)
				break;
			d=other.getD(j);
			a=getP(i);
			if(d<a.start) j++;
			else if(d>=a.end) i++;
			else return true;
		}
		return false;
	}
}

class ColorReg {
	int num;
	int degree;
	public int compare(ColorReg other) {
		if (this.degree < other.degree)
			return -1;
		else if (this.degree > other.degree)
			return 1;
		else
			return 0;
	}

	public ColorReg(int a, int b) {
		this.num = a;
		this.degree = b;
	}
}

class Comparer implements Comparator<ColorReg> {
	@Override
	public int compare(ColorReg a, ColorReg b) {
		// TODO Auto-generated method stub
		if (a.degree < b.degree)
			return -1;
		if (a.degree > b.degree)
			return 1;
		return 0;
	}
}
class SpilledST{
	int RS;int RD;
	public SpilledST(){RS=RD=-1;}
}
/**
 * Provides default methods which visit each node in the tree in depth-first
 * order. Your visitors may extend this class.
 */
public class Kangavisitor implements GJVisitor1<Object, st> {
	HashMap<String, Integer> labels;
	HashMap<Integer, Integer> given_Colors;
	int status;/*0,1,2*/
	int spillArg;
	int MSpillSize;/*max spill size*/
	int MParaNum;/*max para number*/
	int ParaNum;
	st [] v;/*store infomation for sentences*/
	AlivePeriod [] Periods;
	Vector<LinkedList<Integer>> matrix;/*graph*/
	Vector<Integer> degree;
	HashMap<Integer, SpilledST> spilledSTs;/*swap register for spilled sentences*/
	Vector<Integer> temps;/*i->temp m*/
	HashMap<Integer, Integer> tempNums;/*temp m->i*/
	
	void Println(String s) {
		System.out.println();
		System.out.print(s);
	}
	void Print(String s) {
		System.out.print(s);
	}
	int getAvailableReg(int r, int num) 
	{
		int spillReg;
		SpilledST st=spilledSTs.get(num);
		if(r!=1)	
		{
			if(st.RD>0) spillReg=st.RD;
			else spillReg=st.RS;
		}
		else  spillReg=st.RS;
		spillReg = given_Colors.get(spillReg);
		return spillReg;
	}
	int swapIntoReg(int rd, int r, int num) 
	{
		int pos=given_Colors.get(rd);
		if(pos>=0) return pos;
		int spillReg=getAvailableReg(r, num);
		Println(" ALOAD " + getReg(spillReg) + " SPILLEDARG " + (-pos));
		return spillReg;
	}
	/**
	 * f0 -> "MAIN" f1 -> StmtList() f2 -> "END" f3 -> ( Procedure() )* f4 ->
	 * <EOF>
	 */
	public Object visit(Goal n, st argu) {
		Object _ret = null;
		n.f1.procedure = null;
		n.f1.returnTemp = -1;
		n.f1.accept(this, argu);
		n.f3.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> Label() f1 -> "[" f2 -> IntegerLiteral() f3 -> "]" f4 -> StmtExp()
	 */
	public Object visit(Procedure n, st argu) {
		Object _ret = null;
		n.f4.procedure = n;
		n.f4.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> "NOOP"
	 */
	public Object visit(NoOpStmt n, st v) {
		Object _ret = null;
		if (status == 2)
			System.out.print(" NOOP");
		return _ret;
	}

	/**
	 * f0 -> "ERROR"
	 */
	public Object visit(ErrorStmt n, st argu) {
		Object _ret = null;
		if (status == 2)
			Println(" ERROR");
		return _ret;
	}
	/**
	 * f0 -> "CJUMP" f1 -> Temp() f2 -> Label()
	 */
	public Object visit(CJumpStmt n, st v) {
		int rd = Integer.parseInt(n.f1.f1.f0.tokenImage);
		if (0 == status) 
		{
			v.use.add(rd);
			v.follow = n.f2.f0.tokenImage;
		} 
		else if (status == 2) {
			int posR = swapIntoReg(rd,1, v.num);
			Println(" CJUMP " + getReg(posR) + " " + n.f2.f0.tokenImage);
		}
		return null;
	}
	/**
	 * f0 -> "JUMP" f1 -> Label()
	 */
	public Object visit(JumpStmt n, st v) {
		Object _ret = null;
		if (0 == status) {
			v.follow = n.f1.f0.tokenImage;
			v.jump = true;
		}
		if (2 == status)
			Println(" JUMP " + n.f1.f0.tokenImage);
		return _ret;
	}

	/**
	 * f0 -> "HSTORE" f1 -> Temp() f2 -> IntegerLiteral() f3 -> Temp()
	 */
	public Object visit(HStoreStmt n, st v) {
		Object _ret = null;
		int rd = Integer.parseInt(n.f1.f1.f0.tokenImage);
		int rs = Integer.parseInt(n.f3.f1.f0.tokenImage);
		if (0 == status) 
		{
			v.use.add(rd);
			v.use.add(rs);
			v.MSwapRegNeeded=2;
		} 
		else if (2 == status) 
		{
			int l=given_Colors.get(rd);
			int r=given_Colors.get(rs);
			int posR=r,posL=l;
			if(r<=0) 	posR=swapIntoReg(rs,2, v.num);
			if(l<=0)   	posL=swapIntoReg(rd,1,v.num);
			Println(" HSTORE" + getReg(posL) + " " + n.f2.f0.tokenImage
					+ getReg(posR));
			//////////////////////if(l<=0)	Println(" ASTORE SPILLEDARG "+ (-l)+ getReg(posL));
		}
		return _ret;
	}

	/**
	 * f0 -> "HLOAD" f1 -> Temp() f2 -> Temp() f3 -> IntegerLiteral()
	 */
	public Object visit(HLoadStmt n, st v) {
		Object _ret = null;
		int rd = Integer.parseInt(n.f1.f1.f0.tokenImage);
		int rs = Integer.parseInt(n.f2.f1.f0.tokenImage);
		if (0 == status) {
			v.def = rd;
			v.use.add(rs);
		} 
		else if (2 == status) 
		{
			int l=given_Colors.get(rd);
			int r=given_Colors.get(rs);
			int posR=r,posL=l;
			if(r<=0) 	posR=swapIntoReg(rs,1, v.num);
			if(l<=0)	posL=getAvailableReg(0, v.num);
			Println(" HLOAD" + getReg(posL)+ getReg(posR)+" "+n.f3.f0.tokenImage);
			if(l<=0)	Println(" ASTORE SPILLEDARG "+ (-l)+ getReg(posL));
		}
		return _ret;
	}

	/**
	 * f0 -> "MOVE" f1 -> Temp() f2 -> Exp()
	 */
	public Object visit(MoveStmt n, st v) {
		Object _ret = null;
		int rd = Integer.parseInt(n.f1.f1.f0.tokenImage);
		if (0 == status) {
			v.def = rd;
		}
		n.f2.accept(this, v);
		return _ret;
	}

	/**
	 * f0 -> "PRINT" f1 -> SimpleExp()
	 */
	public Object visit(PrintStmt n, st argu) {
		Object _ret = null;
		if (2 == status) 
		{
			if (!argu.use.isEmpty()) 
			{
				int r = argu.use.firstElement();
				int posL = swapIntoReg(r,1,argu.num);
				Println(" PRINT " + getReg(posL));
				return null;
			}
			Println(" PRINT");
		}
		n.f1.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> Call() | HAllocate() | BinOp() | SimpleExp()
	 */
	public Object visit(Exp n, st argu) {
		/*move temp a exp n*/
		 //* when n.f0.which==3 ,exp n is a simple-exp, and will be handled differently
		if (n.f0.which ==3 && status == 2) 
		{    
			int rd = argu.def,l;
			int posL=0,posR=0;
			l = given_Colors.get(rd);
			/*if exp n is a temp ===== move temp a temp b*/
			if (!argu.use.isEmpty()) 
			{
				int rs = argu.use.firstElement();
				if(rs==rd) return null; /*a==b*/
				posR = swapIntoReg(rs,1,argu.num);/*temp b now is put in register s*/
			}
			if (l > 0) posL=l;
			else	posL=getAvailableReg(0,argu.num);
			if(argu.use.isEmpty()||posL!=posR)
			{
				Println(" MOVE " + getReg(posL));
				if(argu.use.isEmpty()) n.f0.accept(this, argu);
				else 	Print(getReg(posR));
			}
			if(l<=0)	Println(" ASTORE SPILLEDARG " + (-l)+getReg(posL));		
			return null;
		}
		n.f0.accept(this, argu);
		return null;
	}

	/**
	 * f0 -> Temp() | IntegerLiteral() | Label()
	 */
	public Object visit(SimpleExp n, st argu) {
		Object _ret = null;
		/* to tell label from label-noop by this null */
		/* n.f0.which==2 means a label */
		if (n.f0.which == 2)
			n.f0.accept(this, null);
		else
			n.f0.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> "CALL" f1 -> SimpleExp() f2 -> "(" f3 -> ( Temp() )* f4 -> ")"
	 */
	public Object visit(Call n, st v) {
		Object _ret = null;
		int i, a = 0, b = 0, c = 0,size=0;
		if (0 == status) {
			v.call=true;
			n.f1.accept(this, v);
			n.f3.accept(this, v);
		} 
		else if (1 == status) {
			/* OLD regs MAY be pushed */
			Iterator<Integer> lt = v.v_out.iterator();
			while (lt.hasNext()) 
			{
				i = lt.next();
				a = given_Colors.get(i);
				if (v.def != i)
					if((a>= 18 && a < 28)||(a>=4&&a<8)) 
				{
					size++;
				}
			}
			/* SPILLED variables OF the called function will be pushed */
			b = n.f3.size();
			MParaNum = (MParaNum > b ? MParaNum : b);
			MSpillSize = (MSpillSize < spillArg + size ? spillArg + size : MSpillSize);
		} 
		else {
			int r, rd, j;
			/*push */
			Iterator<Integer> lt = v.v_out.iterator();
			while (lt.hasNext()) {
				i = lt.next();
				a = given_Colors.get(i);
				if (v.def != i)
					if((a>= 18 && a < 28)||(a>=4&&a<8)) 
				{
					Println(" ASTORE SPILLEDARG "+ (spillArg + size)+ getReg(a));
					size++;
				}
			}
			/* call temp a,[temp b,temp c,temp d...]->use={a,b,c,d}>n.f3,j=1 */
			/* call 'identifier' [b,c,d]->use={b,c,d}=n.f3,j=0 */
			if (v.use.size() == n.f3.size())
				j = 0;
			else
				j = 1;
			/*assign a0-a3 */
			for (i = 0; i < n.f3.size() && i < 4; i++) 
			{
				rd = v.use.elementAt(i + j);
				r = swapIntoReg(rd,1,v.num);
				Println(" MOVE " + getReg(i + 4) + getReg(r));
			}
			/* push a4-an*/
			for (i = 4; i < n.f3.size(); i++) 
			{
				rd = v.use.elementAt(i + j);
				r = swapIntoReg(rd,1,v.num);
				Println(" PASSARG "+ (i-3) + getReg(r));
				size++;
			}	
			/* call a */
			if (j > 0) 
			{
				rd = v.use.elementAt(0);
				r = swapIntoReg(rd,1,v.num);
				Println(" CALL " + getReg(r));
			} 
			else 
			{
				Println(" CALL ");
				n.f1.accept(this, v);
			}		
			/* move rd call a [b,c,d] */
			if(given_Colors.containsKey(v.def)) {
				int l=given_Colors.get(v.def);
				if(l>0) rd=l;
				else rd=getAvailableReg(0, v.num);
				if(rd!=26) Println(" MOVE " + getReg(rd) + " v0");
				if(l<=0)
					Println(" ASTORE SPILLEDARG " + (-l)+ getReg(rd));
			}
			size = 0;
			/* pop */
			lt = v.v_out.iterator();
			while (lt.hasNext()) 
			{
				i = lt.next();
				a = given_Colors.get(i);
				if (v.def != i)
					if((a>= 18 && a < 28)||(a>=4&&a<8)) 
				{
					Println(" ALOAD " + getReg(a) + " SPILLEDARG "
							+ (spillArg + size));
					size++;
				}
			}
		}
		return _ret;
	}

	/**
	 * f0 -> "HALLOCATE" f1 -> SimpleExp()
	 */
	public Object visit(HAllocate n, st v) {
		Object _ret = null;
		if (2 == status) 
		{
			int l, posL,posR=0;
			int rd = v.def, r;
			l = given_Colors.get(rd);
			if (!v.use.isEmpty()) 
			{
				r = v.use.firstElement();
				posR = swapIntoReg(r,1,v.num);
			}
			if (l > 0) posL=l;
			else posL=getAvailableReg(0,v.num);
			Println(" MOVE " + getReg(posL)+" HALLOCATE");
			if(!v.use.isEmpty()) Print(getReg(posR));
			else	n.f1.accept(this, v);
			if(l<=0)	Println(" ASTORE SPILLEDARG " + (-l)+getReg(posL));		
			return null;
		}
		n.f1.accept(this, v);
		return _ret;
	}

	/**
	 * f0 -> Operator() f1 -> Temp() f2 -> SimpleExp()
	 */
	public Object visit(BinOp n, st v) {
		int rs = Integer.parseInt(n.f1.f1.f0.tokenImage);
		if (0 == status) 
		{
			v.use.add(rs);
			n.f2.accept(this, v);
			if(v.use.size()>=2) v.MSwapRegNeeded=2;
			return null;
		}
		/* OUTPUT STAGE */
		/* move temp a op TEMP b c */
		else if (2 == status) 
		{
			int l,r1=rs,r2,posL,posR1,posR2=0;
			int rd = v.def;
			/* A,B*/
			l = given_Colors.get(rd);
			posR1 = swapIntoReg(r1,1,v.num);
			/* IF TEMP C EXISTS*/
			if (v.use.size() > 1) 
			{  
				r2 = v.use.elementAt(1);
				if(r1!=r2)posR2 = swapIntoReg(r2,2,v.num);
				else posR2=posR1;
			}
			if(l<=0)
				posL=getAvailableReg(0,v.num);
			else
				posL=l;
			Println(" MOVE " + getReg(posL));
			n.f0.accept(this, v);
			if(v.use.size()>1)
				Print(getReg(posR1) + getReg(posR2));
			else
			{
				Print(getReg(posR1));
				n.f2.accept(this, v);
			}
			if(l<=0)	Println(" ASTORE SPILLEDARG " + (-l)+getReg(posL));
			return null;
		}
		return null;
	}

	/**
	 * f0 -> "LT" | "PLUS" | "MINUS" | "TIMES"
	 */
	public Object visit(Operator n, st argu) {
		Object _ret = null;
		if (2 == status) {
			int s = n.f0.which;
			if (s == 0)
				System.out.print(" LT");
			else if (s == 1)
				System.out.print(" PLUS");
			else if (s == 2)
				System.out.print(" MINUS");
			else if (s ==3)
				System.out.print(" TIMES");
		}
		return _ret;
	}

	/**
	 * f0 -> "TEMP" f1 -> IntegerLiteral()
	 */
	public Object visit(Temp n, st v) {
		Object _ret = null;
		int rd = Integer.parseInt(n.f1.f0.tokenImage);
		/* INITIALIZE STAGE */
		if (0 == status) 
		{
				v.use.add(rd);
		}
		/* OUTPUT STAGE */
		else if (2 == status)
			;
		return _ret;
	}

	/**
	 * f0 -> <INTEGER_LITERAL>
	 */
	public Object visit(IntegerLiteral n, st argu) {
		Object _ret = null;
		/* OUTPUT */
		if (2 == status)
			System.out.print(" " + n.f0.tokenImage);
		return _ret;
	}

	/**
	 * f0 -> <IDENTIFIER>
	 */
	public Object visit(Label n, st v) {
		Object _ret = null;
		/* IF V==NULL,THEN THE LABEL PLAYS AN OBJECTIVE PART IN STATEMENTS */
		/* OR,THE LABEL IS A NOOP */
		if (0 == status) { /* MARK THE NOOP-NODE IN STMTLIST */
			if (v != null)
				v.label = n.f0.tokenImage;
		}
		/* OUTPUT STAGE */
		else if (2 == status) {
			if (v != null)
				Println("");/* LABEL NOOP */
			Print(" " + n.f0.tokenImage);
		}
		return _ret;
	}

	/**
	 * f0 -> "BEGIN" f1 -> StmtList() f2 -> "RETURN" f3 -> SimpleExp() f4 ->
	 * "END"
	 */
	public Object visit(StmtExp n, st argu) {
		status = 0;
		st v = new st();
		n.f3.accept(this, v);
		if (v.use.size() > 0)
			n.f1.returnTemp = v.use.firstElement();
		else
			n.f1.returnTemp = -1;
		n.f1.procedure = n.procedure;
		n.f1.accept(this, argu);
		return null;
	}

	/**
	 * f0 -> ( ( Label() )? Stmt() )*
	 */
	public Object visit(StmtList n, st argu) {
		Object _ret = null;
		int i, j, m, k;
		Node nodei;
		Vector<Node> nodes = n.f0.nodes;
		HashSet<Integer> Htemps = new HashSet<Integer>();
		temps = new Vector<Integer>();
		/* every node represents a sentence ,and give it an alive analysis */
		m = nodes.size();
		v = new st[m+1];
		for (i = 0; i <= m; i++)
			v[i]=new st();
		labels = new HashMap<String, Integer>();
		/* visit sentences,and initialize st[] */
		status = 0;
		/*µÚÒ»´Îvisit*/
		for (i = 0; i < m; i++) 
		{
			nodei = nodes.elementAt(i);
			nodei.accept(this, v[i]);
			Htemps.addAll(v[i].use);
			//if(v[i].def>=0) Htemps.add(v[i].def);
			v[i].num = i;
			if (v[i].label != null)
				labels.put(v[i].label, i);
		}
		/* visit return sentence */
		if (n.returnTemp >= 0)
		{	v[m].use.add(n.returnTemp);
			v[m].v_in.add(n.returnTemp);
			Htemps.addAll(v[m].use);
		}
		/**/
		temps.addAll(Htemps);
		quickSort(0, temps.size() - 1, temps);
		int n1 = temps.size();
		tempNums = new HashMap<Integer, Integer>();
		for (i = 0; i < n1; i++)
			tempNums.put(temps.elementAt(i), i);
		/* fill back the (c)jump labels */
		for (i = 0; i < m; i++) 
		{
			if (v[i].follow != null)
				v[i].jumpSt = labels.get(v[i].follow);
		}
		/* get v_in for sentences */
		boolean[] stChange = new boolean[m + 1];
		for (i = m; i >= 0; i--)
			stChange[i] = true;
		boolean change = true;
		while (change) {
			change = false;
			for (i = m - 1; i >= 0; i--) 
			{
				///...stChange[i] = true;///////....
				k = v[i].jumpSt;
				if (k >= 0 && stChange[k])
					v[i].v_out.addAll(v[k].v_in);
				if (!v[i].jump && stChange[i + 1])
					v[i].v_out.addAll(v[i + 1].v_in);
				/* check if changed */
				int PreSize = v[i].v_in.size();
				v[i].v_in.addAll(v[i].v_out);
				if (v[i].def >= 0)
					v[i].v_in.remove(v[i].def);
				v[i].v_in.addAll(v[i].use);
				int NewSize = v[i].v_in.size();
				if (NewSize > PreSize) {
					change = true;
					stChange[i] = true;
				}
			}
		}
		/* get alive period for temps */
		int start, tempi;
		Periods = new AlivePeriod[n1];
		for (i = 0; i < n1; i++)
		Periods[i]=new AlivePeriod();
		i = 0;

		for (i=0; i < n1; i++) {
			start = -1;
			tempi = temps.elementAt(i);
			for (j = 0; j <= m; j++) 
			{
				if(v[j].use.contains(tempi))
                {
                    Periods[i].putU(j);
                }
				else if(v[j].def==tempi)
                {
                    Periods[i].putD(j);
                }
				if (v[j].v_in.contains(tempi)) {
					if (start < 0)
						start = j;
				}
				else 
				{	
					if (start >= 0) 
                    {
                        Periods[i].putP(start, j - 1);
                        start = -1;
                    }
                }   
			}
			if (start >= 0)
				Periods[i].putP(start, j - 1);
		}

		/* now make the graph */
		/* we can fairly color the nodes afterwards */
		degree = new Vector<Integer>();
		for (i = 0; i < n1; i++)
			degree.add(0);
		matrix = new Vector<LinkedList<Integer>>();
		for (i = 0; i < n1; i++)
			matrix.add(new LinkedList<Integer>());
		Comparer comp = new Comparer();
		PriorityQueue<ColorReg> queue = new PriorityQueue<ColorReg>(30, comp);
		given_Colors = new HashMap<Integer, Integer>();

		for (i=0; i < n1; i++) {
			for (j = i + 1; j < n1; j++) {
				if (Periods[i].overLap(Periods[j])) {
					matrix.elementAt(i).add(j);
					matrix.elementAt(j).add(i);
					int tmp = degree.elementAt(i);
					degree.setElementAt(tmp + 1, i);
					tmp = degree.elementAt(j);
					degree.setElementAt(tmp + 1, j);
				}
			}
			queue.add(new ColorReg(i, degree.elementAt(i)));
		}
		
		int reg;
		ColorReg aR;
		Integer tmp;
		Stack<Integer> colored_Stack = new Stack<Integer>();
		spilledSTs = new HashMap<Integer, SpilledST>();
		HashSet<Integer> colored = new HashSet<Integer>();
		HashSet<Integer> spilled = new HashSet<Integer>();
		int size = 0;
		/* temp0-temp3 -> a0-a3 */
		i=0;
		while (i < temps.size() && temps.elementAt(i) < 4) {
			given_Colors.put(temps.elementAt(i), temps.elementAt(i) + 4);
			colored.add(i);
			i++;
		}
		if (n.procedure == null)
			ParaNum = 0;
		else 	ParaNum = Integer.parseInt(n.procedure.f2.f0.tokenImage);
		for(i=4;i<ParaNum;i++)
		{
			if(!v[0].v_in.contains(i)&&tempNums.containsKey(i))
			{
				reg=tempNums.get(i);
				spill(reg);
				spilled.add(reg);
			}
		}
		boolean success=false;
		while(!success){
			success=true;
			while(!queue.isEmpty())
			{
				aR = queue.poll();
				reg = aR.num;
				if (colored.contains(reg) || spilled.contains(reg))
					continue;
				if (degree.elementAt(reg) <= 22) 
				{
					colored.add(reg);
					colored_Stack.push(reg);
					ListIterator<Integer> it = matrix.elementAt(reg).listIterator(0);
					while (it.hasNext()) 
					{
						k = it.next();
						int tmp1 = degree.elementAt(k);
						degree.setElementAt(tmp1 - 1, k);
						if (!colored.contains(k)) queue.add(new ColorReg(k, degree.elementAt(k)));
					}
				}
				else
				{
					success=false;
					//*some nodes can not be spilled,since it is a swap reg for spilled reg*//
					if(reg>=Periods.length) continue;
					spilled.add(reg);
					spill(reg);	
					queue.clear();
				} 	
			}
			if(!success)
			{	
				colored.clear();
				colored_Stack.clear();
				for (i = 0; i < degree.size(); i++) 
				{
					if(temps.elementAt(i)<4) continue;
					degree.setElementAt(matrix.elementAt(i).size(), i);
					if (!spilled.contains(i))
						queue.add(new ColorReg(i, degree.elementAt(i)));
				}
			}
		}
		/* now we will deliver the colors,using the color-stack*/
		i = 0;
		int temp;
		int SregUsed = 0;
		HashSet<Integer> used_Colors = new HashSet<Integer>();
		while (!colored_Stack.isEmpty()) {
			reg = colored_Stack.pop();
			used_Colors.clear();
			ListIterator<Integer> it = matrix.elementAt(reg).listIterator();
			while (it.hasNext()) {
				k = it.next();
				temp = temps.elementAt(k);
				tmp = given_Colors.get(temp);
				if (tmp != null && tmp > 0)	used_Colors.add(tmp);
			}
			for (i = 8; i <= 27; i++) {
				if (!used_Colors.contains(i))
					break;
			}
			if (i >= 28) 
			{
				for(i=5;i<8;i++)
				{
					if (!used_Colors.contains(i))
						break;
				}
				if(i>=8){
					Println(" coloring failed for some unkown reason");
					return null;
				}
			}
			SregUsed = (SregUsed < i ? i : SregUsed);
			given_Colors.put(temps.elementAt(reg), i);
		}
		/* handle spilling-out variables*/	
		int a = (ParaNum > 4 ? ParaNum - 4 : 0);
		size += a;
		SregUsed -= 7;
		SregUsed = (SregUsed < 0 ? 0 : SregUsed);
		SregUsed = (SregUsed < 10 ? SregUsed : 10);
		size += SregUsed;
		Iterator<Integer> lt = spilled.iterator();
		while (lt.hasNext()) 
		{
			reg = lt.next();
			reg=temps.elementAt(reg);
			if(reg<ParaNum)
			given_Colors.put(reg, -(reg-4));///*a4-an put in memory*///
			else
			given_Colors.put(reg, -(size++));
		}		
		//System.out.println(given_Colors);///
		/* calculate the size of the spilled stack */
		status = 1;
		spillArg =  size;///...
		MSpillSize = spillArg;
		MParaNum = 0;///...
		for (i = 0; i < m; i++) {
			/*
			 * the sentences that defined a variable which will never used below
			 * will be ignored
			 */
			if (v[i].def >= 0
					&& !v[i].v_out.contains(v[i].def)&&v[i].call==false)
				continue;
			else {
				nodei = nodes.elementAt(i);
				nodei.accept(this, v[i]);
			}
		}
		/* output stage*/
		/* this visit will generate real codes*/
		status = 2;
		/* procedure [][][] */
		if (n.procedure == null)
			Println("MAIN[0][" + MSpillSize + "][" + MParaNum + "]");
		else
			Println(n.procedure.f0.f0.tokenImage + "[" + ParaNum + "][" + MSpillSize+ "][" + MParaNum + "]");
		/* push t0-t9 */
		for (i = a; i < a + SregUsed; i++) 
			Println(" ASTORE SPILLEDARG " + i + " t" + (i - a));
		/* pop a4-an if delivered in register and is alive at first*/
		for (i = 0; i < a; i++) 
		{
			if (given_Colors.containsKey(i + 4)) 
			{
				j = given_Colors.get(i + 4);
				if (j > 0&&v[0].v_in.contains(i+4))
					Println(" ALOAD" + getReg(j) + " SPILLEDARG " + (i));
			}
		}
		for (i = 0; i < m; i++) 
		{
			/*
			 * the sentences which defines a variable that is never used below
			 * will be ignored!!!
			 */
			if (v[i].def >= 0
					&& !v[i].v_out.contains(v[i].def)&&v[i].call==false)
				{
					continue;
				}
			else 
			{
				nodei = nodes.elementAt(i);
				nodei.accept(this, v[i]);
			}
		}
		if(n.procedure!=null)
		{
			if (n.returnTemp >= 0) 
			{
				int s = swapIntoReg(n.returnTemp,1,m);
				if(s!=26)
				Println(" MOVE v0" + getReg(s));
			}
			else
			{
				Println(" MOVE v0");
				n.procedure.f4.f3.accept(this, null);
			}
		}
		/* pop t0-t9 */
		for (i = a; i < a + SregUsed; i++) {
			Println(" ALOAD "+" t" + (i - a)+" SPILLEDARG " + i);
		}
		Println("END");
		return _ret;
	}
	/**
	 * f0 -> NoOpStmt() | ErrorStmt() | CJumpStmt() | JumpStmt() | HStoreStmt()
	 * | HLoadStmt() | MoveStmt() | PrintStmt()
	 */
	
	/*used to get register name*/
	public String getReg(int pos) 
	{
		if (pos >= 4) {
			if (pos < 8)
				return (" a" + (pos - 4));
			if (pos < 18)
				return (" t" + (pos - 8));
			if (pos < 26)
				return (" s" + (pos - 18));
			if(pos<28)
				return (" v"+(pos-26));
		}
		return null;
	}
	/*when a variable spilled,used to change the graph*/
	public void spill(int n) 
	{
		int i, j, k,  s, t, size;
		/* clear the node in the graph */
		Integer tmp = n;
		Iterator<Integer> n1 = matrix.elementAt(n).iterator();
		while  (n1.hasNext()) 
		{
			j = n1.next();
			matrix.elementAt(j).remove(tmp);
		}
		matrix.elementAt(n).clear();
		tmp=temps.elementAt(n);
		/* generate new nodes */
		int MSwapRegNum=0;
		size=Periods[n].usePoints.size();
		int p=0;
		while(p<size)
		{
			j=Periods[n].usePoints.elementAt(p);
			++p;
			MSwapRegNum=v[j].MSwapRegNeeded;
			SpilledST st= spilledSTs.get(j);
			if(st!=null)
			{
				if(MSwapRegNum==1)
				{
					if(st.RS>0)	continue;
				}
			}
			if(st==null) st=new SpilledST();
			/*add a variable*/
			matrix.add(new LinkedList<Integer>());
			s = matrix.size() - 1;
			degree.add(0);
			t=temps.lastElement() + 1;
			temps.add(t);
			tempNums.put(t,s);
			HashSet<Integer> excluSet=v[j].v_in;
			/*n is out from sentence j*/
			excluSet.remove(tmp);
			/*t is added*/
			Iterator<Integer> m1 = excluSet.iterator();
			while (m1.hasNext()) 
			{
				i = m1.next();
				k=tempNums.get(i);
				matrix.elementAt(k).add(s);
				matrix.elementAt(s).add(k);
			}
			if(MSwapRegNum==2) excluSet.add(t);
			if(st.RS>0)		st.RD=t;
			else{
					st.RS=t;
					st.RD=-1;
			}
			spilledSTs.put(j,st);
		}
		size=Periods[n].defPoints.size();
		p=0;
		while(p<size)
		{
			j=Periods[n].defPoints.elementAt(p);
			++p;
			SpilledST st= spilledSTs.get(j);
			if(st!=null)
			{
				if(st.RS>0)	continue;
			}
			if(st==null) st=new SpilledST();
			/*add a variable*/
			matrix.add(new LinkedList<Integer>());
			s = matrix.size() - 1;
			degree.add(0);
			t=temps.lastElement() + 1;
			temps.add(t);
			tempNums.put(t,s);
			HashSet<Integer> excluSet=v[j].v_out;
			/*t is added*/
			Iterator<Integer> m1 = excluSet.iterator();
			while (m1.hasNext()) 
			{
				i = m1.next();
				if(i==tmp) continue;
				k=tempNums.get(i);
				matrix.elementAt(k).add(s);
				matrix.elementAt(s).add(k);
			}
			st.RD=t;
			spilledSTs.put(j,st);
		}		
}
	/*used to sort temps*/
	void quickSort(int left, int right, Vector<Integer> s) {
		if (right > left) {
			Integer o1 = s.elementAt(right);
			int i = left - 1;
			int j = right;
			while (true) {
				while (s.elementAt(++i) < o1);
				while (j > 0)
					if (s.elementAt(--j) <= o1)
						break; // out of while
				if (i >= j)
					break;
				swap(i, j, s);
			}
			swap(i, right, s);
			quickSort(left, i - 1, s);
			quickSort(i + 1, right, s);
		}
	}
	void swap(int loc1, int loc2, Vector<Integer> s) {
		int tmp = s.elementAt(loc1);
		s.setElementAt(s.elementAt(loc2), loc1);
		s.setElementAt(tmp, loc2);
	}


public Object visit(NodeList n, st argu) {
	Object _ret = null;
	int _count = 0;
	for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
		e.nextElement().accept(this, argu);
		_count++;
	}
	return _ret;
}
public Object visit(NodeListOptional n, st argu) {
	if (n.present()) {
		Object _ret = null;
		int _count = 0;
		for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
			e.nextElement().accept(this, argu);
			_count++;
		}
		return _ret;
	} else
		return null;
}
public Object visit(NodeOptional n, st argu) {
	if (n.present())
		return n.node.accept(this, argu);
	else
		return null;
}
public Object visit(NodeSequence n, st argu) {
	Object _ret = null;
	int _count = 0;
	for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
		e.nextElement().accept(this, argu);
		_count++;
	}
	return _ret;
}
public Object visit(NodeToken n, st argu) {
	return null;
}
public Object visit(Stmt n, st follow) {
	return n.f0.accept(this, follow);
}}