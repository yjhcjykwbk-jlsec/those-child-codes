 //
// Generated by JTB 1.3.2
//
package visitor;
import syntaxtree.*;
import java.util.*;
import visitor.st;
class Period {
	int start, end;
	public Period(int a, int b) {
		start = a;
		end = b;
	}
}
class alivePeriod {
	Vector<Period> periods;
	Vector<Integer> usedPoints;
	public alivePeriod() {
		periods = new Vector<Period>();
		usedPoints=new Vector<Integer>();
	}
	public Period getP(int i) {
		return periods.elementAt(i);
	}
	public void putP(int a, int b) 
	{
		periods.add(new Period(a, b));
	}
	public int getQ(int i) {return usedPoints.elementAt(i);}
	public void putQ(int a) { usedPoints.add(a);}
	public boolean overLap(alivePeriod other) {
		int j = 0, sizej = other.periods.size();
		int i = 0, sizei = this.periods.size();
		Period a, b;
		while (true) {
			if (j >= sizej || i >= sizei)
				return false;
			a = this.getP(i);
			b = other.getP(j);
			if (a.end < b.start)
				i++;
			else if (b.end < a.start)
				j++;
			else
				return true;
		}
	}
}
class colorReg {
	int num;
	int degree;
	public int compare(colorReg other)
	{
		if(this.degree<other.degree) return -1;
		else if(this.degree>other.degree) return 1;
		else return 0;
	}
	public colorReg(int a,int b)
	{
		this.num=a;this.degree=b;
	}                    
}
class comparer implements Comparator<colorReg>
{
	@Override
	public int compare(colorReg a, colorReg b) {
		// TODO Auto-generated method stub
		if(a.degree<b.degree) return -1;
		if(a.degree>b.degree) return 1;
		return 0;
	}
}
/**
 * Provides default methods which visit each node in the tree in depth-first
 * order. Your visitors may extend this class.
 */
public class GJDepthFirst implements GJVisitor<Object, st> {
	//
	// Auto class visitors--probably don't need to be overridden.
	//
	HashMap<String, Integer> labels;
	HashMap<Integer,Integer> given_Colors;
	int status;
	int spillArg;
	int spillSize;
	int vaSize;
	Vector<st> v;
	Vector<alivePeriod> Periods;
	Vector<LinkedList<Integer>> matrix;
	Vector<Integer> degree;
	HashMap<Integer,Integer[]> spilledTemps;
	HashMap<Integer,Integer> tempNums;
	Vector<Integer> temps;
	public Object visit(NodeList n, st argu) {
		Object _ret = null;
		int _count = 0;
		for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
			e.nextElement().accept(this, argu);
			_count++;
		}
		return _ret;
	}
	public Object visit(NodeListOptional n, st argu) {
		if (n.present()) {
			Object _ret = null;
			int _count = 0;
			for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
				e.nextElement().accept(this, argu);
				_count++;
			}
			return _ret;
		} else
			return null;
	}
	public Object visit(NodeOptional n, st argu) {
		if (n.present())
			return n.node.accept(this, argu);
		else
			return null;
	}
	public Object visit(NodeSequence n, st argu) {
		Object _ret = null;
		int _count = 0;
		for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
			e.nextElement().accept(this, argu);
			_count++;
		}
		return _ret;
	}
	public Object visit(NodeToken n, st argu) {
		return null;
	}
	void Println(String s)
	{
		System.out.println();
		System.out.print(s);
	}
	void Print(String s)
	{
		System.out.print(s);
	}
	/*this function is very important,since it can swap variables from memory to register*/	
	int getSpilledReg(int rd,int num)
	{
		int pos=given_Colors.get(rd);
		if(pos>=0) return pos;
		/*spilledTemps recorded the spilled nodes for node rd*/
		int preNum=spilledTemps.get(rd)[0];
		if(num>preNum) spilledTemps.get(rd)[1]+=1;
		int spillReg=spilledTemps.get(rd)[1];
		Println(" ALOAD "+getReg(spillReg)+" SPILLEDARG "+(-pos));
		return spillReg;
	}
	/**
	 * f0 -> "MAIN" f1 -> StmtList() f2 -> "END" f3 -> ( Procedure() )* f4 ->
	 * <EOF>
	 */
	public Object visit(Goal n, st argu) {
		Object _ret = null;
		n.f1.procedure=null;
		n.f1.returnTemp=-1;
		n.f1.accept(this, argu);
		n.f3.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> Label() f1 -> "[" f2 -> IntegerLiteral() f3 -> "]" f4 -> StmtExp()
	 */
	public Object visit(Procedure n, st argu) {
		Object _ret = null;
		n.f4.procedure=n;
		n.f4.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> "NOOP"
	 */
	public Object visit(NoOpStmt n, st v) {
		Object _ret = null;
		if(status==2) System.out.print(" NOOP");
		return _ret;
	}

	/**
	 * f0 -> "ERROR"
	 */
	public Object visit(ErrorStmt n, st argu) {
		Object _ret = null;
		if(status==2) Println(" ERROR");
		return _ret;
	}

	/**
	 * f0 -> "CJUMP" f1 -> Temp() f2 -> Label()
	 */
	public Object visit(CJumpStmt n, st v) 
	{
		int rd=Integer.parseInt(n.f1.f1.f0.tokenImage);
		if(0==status)
		{
			v.use.add(rd);
			v.follow = n.f2.f0.tokenImage;
		}
		else if(status==2) 
		{
			int pos=getSpilledReg(rd,v.num);
			Println(" CJUMP "+getReg(pos)+" "+n.f2.f0.tokenImage);
		}
		return null;
	}

	/**
	 * f0 -> "JUMP" f1 -> Label()
	 */
	public Object visit(JumpStmt n, st v) {
		Object _ret = null;
		if(0==status)
		{
			v.follow = n.f1.f0.tokenImage;
			v.jump = true;
		}
		if(2==status) Println(" JUMP "+n.f1.f0.tokenImage);
		return _ret;
	}

	/**
	 * f0 -> "HSTORE" f1 -> Temp() f2 -> IntegerLiteral() f3 -> Temp()
	 */
	public Object visit(HStoreStmt n, st v) {
		Object _ret = null;
		int rd=Integer.parseInt(n.f1.f1.f0.tokenImage);
		int rs=Integer.parseInt(n.f3.f1.f0.tokenImage);
		if(0==status)
		{
			v.use.add(rs);
			if(rs!=rd) v.use.add(rd);
		}
		else if(2==status)
		{
			int posL=getSpilledReg(rd,v.num);
			int posR=getSpilledReg(rs,v.num);
			Println(" HSTORE"+getReg(posL)+" "+n.f2.f0.tokenImage+getReg(posR));
		}
		return _ret;
	}

	/**
	 * f0 -> "HLOAD" f1 -> Temp() f2 -> Temp() f3 -> IntegerLiteral()
	 */
	public Object visit(HLoadStmt n, st v) {
		Object _ret = null;
		int rd=Integer.parseInt(n.f1.f1.f0.tokenImage);
		int rs=Integer.parseInt(n.f2.f1.f0.tokenImage);
		if(0==status)
		{
			v.def=rd;
			v.use.add(rs);
		}
		else if(2==status)
		{
			int posL=getSpilledReg(rd,v.num);
			int posR=getSpilledReg(rs,v.num);
			Println(" HLOAD "+getReg(posL)+getReg(posR)+" "+n.f3.f0.tokenImage);
		}
		return _ret;
	}

	/**
	 * f0 -> "MOVE" f1 -> Temp() f2 -> Exp()
	 */
	public Object visit(MoveStmt n, st v) {
		Object _ret = null;
		int rd=Integer.parseInt(n.f1.f1.f0.tokenImage);
		if(0==status)
		{
		  v.def=rd;
		}
		n.f2.accept(this,v);
		return _ret;
	}

	/**
	 * f0 -> "PRINT" f1 -> SimpleExp()
	 */
	public Object visit(PrintStmt n, st argu) {
		Object _ret = null;
		if(2==status)
		{
			if(!argu.use.isEmpty()) 
			{
				int rd=argu.use.firstElement();
				int posL=getSpilledReg(rd,argu.num);
				Println(" PRINT "+getReg(posL));
				return null;
			}
			Println(" PRINT");
		}
		n.f1.accept(this,argu);
		return _ret;
	}

	/**
	 * f0 -> Call() | HAllocate() | BinOp() | SimpleExp()
	 */
	public Object visit(Exp n, st argu) 
	{
		/*handle "move temp a temp b" */
		/*n.f0.which==3 means n is a simple-exp,and simple-exp is always handled differently*/
		if(n.f0.which==3&&status==2)
		{
			int rd=argu.def;
			int l=given_Colors.get(rd);
			if(argu.use.size()>0) 
			{
				int rs=argu.use.firstElement();
				int r=getSpilledReg(rs,argu.num);
				if(rd!=rs)
				{
					if(l>=0&&l!=r) Println(" MOVE "+getReg(l)+getReg(r));
					else if(l<0) Println(" ASTORE SPILLEDARG "+(-l)+getReg(r));
				}				
				return null;
			}
			if(l>=0) Println(" MOVE "+getReg(l));
			else Println(" ASTORE SPILLEDARG "+(-l));
		}
		n.f0.accept(this, argu);
		return null;
	}
	/**
	 * f0 -> Temp() | IntegerLiteral() | Label()
	 */
	public Object visit(SimpleExp n, st argu) {
		Object _ret = null;
		/*to tell label from label-noop by this null*/
		/*n.f0.which==2 means a label*/
		if(n.f0.which==2) n.f0.accept(this,null);
		else n.f0.accept(this,argu);
		return _ret;
	}
	/**
	 * f0 -> "CALL" f1 -> SimpleExp() f2 -> "(" f3 -> ( Temp() )* f4 -> ")"
	 */
	public Object visit(Call n, st v) {
		Object _ret = null;
		int i,a=0,b=0,c=0;
		if(0==status) 
			{
			n.f1.accept(this,v);
			n.f3.accept(this,v);
			}
		else if(1==status)
		{
			/*OLD a0-a3 may be pushed*/
			for(i=0;i<4;i++)
			{
				if(v.v_in.contains(i)) a++;
			}
			/*OLD t regs MAY be pushed*/
			Iterator<Integer>lt=v.v_in.iterator();
			while(lt.hasNext())
			{
				i=lt.next();
				c=given_Colors.get(i);
				if(v.v_out.contains(i)&&v.def!=i&&c>=8&&c<18) a++;
			}
			/*SPILLED variables OF the called function will be pushed */
			b=n.f3.size();
			vaSize=(vaSize>b?vaSize:b);
			b=(b>4?(b-4):0);
			a+=b;
			spillSize=(spillSize<spillArg+a?spillArg+a:spillSize);
		}
		else
		{
			int size=0;
			int r,rd,j;
			/*a0-a3*/
			for(i=0;i<4;i++)
			{
				if(v.v_in.contains(i))
				{
					Println(" ASTORE SPILLEDARG "+(spillArg+size)+getReg(given_Colors.get(i)));
					size++;
				}	
			}
			/*t0-t9*/
			Iterator<Integer>lt=v.v_out.iterator();
			while(lt.hasNext())
			{
				i=lt.next();
				a=given_Colors.get(i);
				if(v.v_out.contains(i)&&v.def!=i&&a>=8&&a<18) 
				{
					Println(" ASTORE SPILLEDARG "+(spillArg+size)+getReg(a));
					size++;
				}
			}
			/*call temp a,[temp b,temp c,temp d...]->use={a,b,c,d}>n.f3,j=1*/
			/*call 'identifier' [b,c,d]->use={b,c,d}=n.f3,j=0*/
			if(v.use.size()==n.f3.size()) j=0;
			else j=1;
			/*a0-a3*/
			for(i=0;i<n.f3.size()&&i<4;i++)
			{
				rd=v.use.elementAt(i+j);
				r=getSpilledReg(rd,v.num);
				Println(" MOVE "+getReg(i+4)+getReg(r));
			}
			/*an*/
			for(i=4;i<n.f3.size();i++)
			{
				rd=v.use.elementAt(i+j);
				r=getSpilledReg(rd,v.num);
				Println(" ASTORE  SPILLEDARG "+size+getReg(r));
				size++;
			}
			/*call a*/
			if(j>0)
				{	rd=v.use.elementAt(0);
					r=getSpilledReg(rd,v.num);
					Println(" CALL "+getReg(r));
				}
			else
				{
					Println(" CALL ");
					n.f1.accept(this,v);
				}
			size=0;
			/*pop a0-a3*/
			for(i=0;i<4;i++)
			{
				if(v.v_in.contains(i))
				{
					Println(" HLOAD"+getReg(given_Colors.get(i))+" SPILLEDARG "+(spillArg+size));
					size++;
				}	
			}
			/*pop t0-t9*/
		    lt=v.v_out.iterator();
			while(lt.hasNext())
			{
				i=lt.next();
				a=given_Colors.get(i);
				if(v.v_out.contains(i)&&v.def!=i&&a>=8&&a<18) 
				{
					Println(" HLOAD " +getReg(a)+" SPILLEDARG "+(spillArg+size));
					size++;
				}
			}
			/*move rd call a [b,c,d]*/
			rd=getSpilledReg(v.def,v.num);
			Println(" MOVE "+getReg(rd)+" v0");
		}
		return _ret;
	}

	/**
	 * f0 -> "HALLOCATE" f1 -> SimpleExp()
	 */
	public Object visit(HAllocate n, st v) {
		Object _ret = null;
		if(2==status)
		{
			int l,r;
			int rd=v.def,rs;
			l=given_Colors.get(rd);
			if(!v.use.isEmpty())
			{
				rs=v.use.firstElement();
				r=getSpilledReg(rs,v.num);
				if(l>=0)Println(" MOVE "+getReg(l)+" HALLOCATE"+getReg(r));
				else Println(" ASTORE SPILLEDARG "+(-l)+" HALLOCATE"+getReg(r));
				return null;	
			}
			if(l>=0)Println(" MOVE "+getReg(l)+" HALLOCATE");
			else Println(" ASTORE SPILLEDARG "+(-l)+" HALLOCATE");
		}
		n.f1.accept(this, v);
		return _ret;
	}

	/**
	 * f0 -> Operator() f1 -> Temp() f2 -> SimpleExp()
	 */
	public Object visit(BinOp n, st v) {
		Object _ret = null;
		int rs=Integer.parseInt(n.f1.f1.f0.tokenImage);
		if(0==status)
		{
			v.use.add(rs);
		}
		/*OUTPUT STAGE*/
		/*move temp a op TEMP b c*/
		else if(2==status)
		{
			int l,r1,r2;
			int rd=v.def;
			/*A LOCATED*/
			l=given_Colors.get(rd);
			/*B IS LOCATED*/
			r1=getSpilledReg(rs,v.num);
			/*IF C MEANS TEMP C*/
			if(v.use.size()>1)
			{  	/*C IS LOCATED*/
				rs=v.use.elementAt(1);
				r2=getSpilledReg(rs,v.num);	
				if(l>=0)Println(" MOVE "+getReg(l));
				else Println(" ASTORE SPILLEDARG "+(-l));
				n.f0.accept(this, v);
				Print(getReg(r1)+getReg(r2));
				return null;
			}
			/*OR, C IS NOT A TEMP*/
			if(l>=0)Println(" MOVE "+getReg(l));
			else Println(" ASTORE SPILLEDARG "+(-l));
			n.f0.accept(this, v);
			Print(getReg(r1));
		}
		n.f2.accept(this, v);
		return _ret;
	}

	/**
	 * f0 -> "LT" | "PLUS" | "MINUS" | "TIMES"
	 */
	public Object visit(Operator n, st argu) {
		Object _ret = null;
		if(2==status)
			{
			int s=n.f0.which;
			if(s==0) System.out.print(" LT");
			else if(s==1)System.out.print(" PLUS");
			else if(s==2)System.out.print(" MINUS");
			else if(s==3)System.out.print(" TIMES");
			}
		return _ret;
	}

	/**
	 * f0 -> "TEMP" f1 -> IntegerLiteral()
	 */
	public Object visit(Temp n, st v) {
		Object _ret = null;
		int rd=Integer.parseInt(n.f1.f0.tokenImage);
		/*INITIALIZE STAGE*/
		if(0==status)
		{
			if(!v.use.contains(rd)) v.use.add(rd);
		}
		/*OUTPUT STAGE*/
		else if(2==status);
		return _ret;
	}

	/**
	 * f0 -> <INTEGER_LITERAL>
	 */
	public Object visit(IntegerLiteral n, st argu) {
		Object _ret = null;
		/*OUTPUT*/
		if(2==status)System.out.print(" "+n.f0.tokenImage);
		return _ret;
	}

	/**
	 * f0 -> <IDENTIFIER>
	 */
	public Object visit(Label n, st v) {
		Object _ret = null;
		/*IF V==NULL,THEN THE LABEL PLAYS AN OBJECTIVE PART IN STATEMENTS*/
		/*OR,THE LABEL IS A NOOP*/
		if(0==status)
		{   /*MARK THE NOOP-NODE IN STMTLIST*/
			if(v!=null) v.label = n.f0.tokenImage;
		}
		/*OUTPUT STAGE*/
		else if(2==status)
		{	
			if(v!=null)	Println("");/*LABEL NOOP*/
			Print(" "+n.f0.tokenImage);
		}
		return _ret;
	}
	
	/**
	 * f0 -> "BEGIN" f1 -> StmtList() f2 -> "RETURN" f3 -> SimpleExp() f4 ->
	 * "END"
	 */
	public Object visit(StmtExp n, st argu) {
		status=0;
		st v=new st();
		n.f3.accept(this,v);
		if(v.use.size()>0)
			n.f1.returnTemp=v.use.firstElement();
		else n.f1.returnTemp=-1;
		n.f1.procedure=n.procedure;
		n.f1.accept(this,argu);
		return null;
	}
	
	
	/**
	 * f0 -> ( ( Label() )? Stmt() )*
	 */
	public Object visit(StmtList n, st argu) {
		Object _ret = null;
		int i,j,m,k;
		Node nodei;
		Vector<Node> nodes = n.f0.nodes;
		HashSet<Integer> Htemps = new HashSet<Integer>();
		temps=new Vector<Integer>();
		/* every node represents a sentence ,and give it an alive analysis */
		v = new Vector<st>();
		m = nodes.size();
		for (i = 0; i <= m; i++) v.add(new st());
		labels = new HashMap<String, Integer>();
		/*visit sentences,and initialize st[]*/		
		status=0;
		for (i = 0; i < m; i++) 
		{
			nodei = nodes.elementAt(i);
			nodei.accept(this, v.elementAt(i));
			v.elementAt(i).num=i;
			if (v.elementAt(i).label != null) 
				labels.put(v.elementAt(i).label, i);
			Htemps.addAll(v.elementAt(i).use);
		}
		/*visit return sentence*/
		if(n.returnTemp>=0) v.elementAt(m).use.add(n.returnTemp);
		/**/
		temps.addAll(Htemps);
		quickSort(0,temps.size()-1,temps);
		int n1 = temps.size();
		tempNums=new HashMap<Integer,Integer>();
		for(i=0;i<n1;i++)tempNums.put(temps.elementAt(i), i);
		/* fill back the (c)jump labels */
		for (i = 0; i < m; i++) 
		{
			if (v.elementAt(i).follow != null)
				v.elementAt(i).jumpSt = labels.get(v.elementAt(i).follow);
		}
		/*get v_in for sentences*/
		boolean[] stChange = new boolean[m+1];
		for (i = m; i >= 0; i--)
			stChange[i] = true;
		boolean change=true;
		while (change) {
			change = false;
			for (i = m - 1; i >= 0; i--) {
				stChange[i] = false;
				k = v.elementAt(i).jumpSt;
				if (k > 0&&stChange[k]) 
					v.elementAt(i).v_out.addAll(v.elementAt(k).v_in);
				if (!v.elementAt(i).jump && stChange[i + 1])
					v.elementAt(i).v_out.addAll(v.elementAt(i+1).v_in);
				/*check if changed*/
				int PreSize=v.elementAt(i).v_in.size();
				v.elementAt(i).v_in.addAll(v.elementAt(i).v_out);
				if(v.elementAt(i).def>=0) v.elementAt(i).v_in.remove(v.elementAt(i).def);
				v.elementAt(i).v_in.addAll(v.elementAt(i).use);
				int NewSize=v.elementAt(i).v_in.size();
				if (NewSize>PreSize) 
				{
					change = true;stChange[i] = true;
				}
			}
		}
		/* get alive period for temps*/
		int start, tempi;
		Periods = new Vector<alivePeriod>();
		for (i = 0; i < n1; i++) 
			Periods.add(new alivePeriod());
		i=0;
		while(i<temps.size()&&temps.elementAt(i)<4) i++;
		for (; i < n1; i++)
		{
			start = -1;tempi = temps.elementAt(i);
			for (j = 0; j <= m; j++) 
			{
				if(v.elementAt(j).use.contains(tempi)) Periods.elementAt(i).putQ(j);
				if (v.elementAt(j).v_in.contains(tempi)){
					if (start < 0) start = j;}
				else if (start >= 0) 
				{
					Periods.elementAt(i).putP(start, j - 1);start = -1;
				}
			}
			if (start >= 0) Periods.elementAt(i).putP(start, j - 1);
		}
		
		/* now make the graph*/
		/*we can fairly color the nodes afterwards */
		degree = new Vector<Integer>();
		for (i = 0; i < n1; i++)
			degree.add(0);
		matrix=new Vector<LinkedList<Integer>>();
		for (i = 0; i < n1; i++)
			matrix.add(new LinkedList<Integer>());
		comparer comp=new comparer();
		PriorityQueue<colorReg> queue=new PriorityQueue<colorReg>(30,comp);
		given_Colors=new HashMap<Integer,Integer>();
		i=0;
		/*temp0-temp3 -> a0-a3*/
		while(i<temps.size()&&temps.elementAt(i)<4)
		{
			given_Colors.put(temps.elementAt(i),temps.elementAt(i)+4); 
			i++;
		}
		/*other variables*/
		for (; i < n1; i++) {
			for (j = i + 1; j < n1; j++) {
				if (Periods.elementAt(i).overLap(Periods.elementAt(j))) {
					matrix.elementAt(i).add(j);
					matrix.elementAt(j).add(i);
					int tmp=degree.elementAt(i);
					degree.setElementAt(tmp+1,i);
					tmp=degree.elementAt(j);
					degree.setElementAt(tmp+1,j);
				}
			}
			queue.add(new colorReg(i,degree.elementAt(i)));
		}
		/*make two stacks,they are spilled_Stack and colored_Stack.*/
		int reg;
		colorReg aR;
		Integer tmp;
		Stack<Integer> colored_Stack=new Stack<Integer>();
		spilledTemps=new HashMap<Integer,Integer[]>();
		HashSet<Integer> colored = new HashSet<Integer>();
		HashSet<Integer> spilled = new HashSet<Integer>();
		while(true)
		{
		colored.clear();
		colored_Stack.clear();
		while(!queue.isEmpty())
		{
			aR = queue.poll();
			reg=aR.num;
			if(colored.contains(reg)||spilled.contains(reg)) continue;
			if(degree.elementAt(reg)<18) 
			{
				ListIterator<Integer> it = matrix.elementAt(reg).listIterator();  
				while(it.hasNext())
				{
					k=it.next();
					int tmp1=degree.elementAt(k);
					degree.setElementAt(tmp1-1, k);
					if(!colored.contains(k)) queue.add(new colorReg(k,degree.elementAt(k)));
				}
			}
			if(degree.elementAt(reg)>18) 
			{
				spilled.add(reg);
				spill(reg);
				for(j=0;j<Periods.elementAt(reg).usedPoints.size();j++)
				{
					int size=v.elementAt(j).v_in.size();
					if(size>18)
					{
						Iterator<Integer> lt=v.elementAt(j).v_in.iterator();
						int regNum=0;
						while(lt.hasNext())
						{
							k=lt.next();
							k=tempNums.get(k);
							if(colored.contains(k)) regNum++;
						}
						if(regNum>=18)
						{
							lt=v.elementAt(j).v_in.iterator();
							while(lt.hasNext())
							{
								k=lt.next();
								k=tempNums.get(k);
								if(!colored.contains(k)&&!spilled.contains(k)) 
								{
									spilled.add(k);
									spill(k);
								}
							}
						}
					}
				}
				queue.clear();
				for(i=0;i<degree.size();i++)
				{
					degree.setElementAt(matrix.elementAt(i).size(), i);
					if(!spilled.contains(i))queue.add(new colorReg(i,degree.elementAt(i)));
				}
				break;
			}
			else
			{
				colored.add(reg);
				colored_Stack.push(reg);
			}
			}
			if(queue.isEmpty()) break;
		}
		
		/*now we will deliver the colors,with the two stacks*/
		i=0;
		int temp;
		int SregUsed=0;
		HashSet<Integer> used_Colors=new HashSet<Integer>();
		while(!colored_Stack.isEmpty())
		{
			reg=colored_Stack.pop();
			used_Colors.clear();
			ListIterator<Integer> it = matrix.elementAt(reg).listIterator();  
			while(it.hasNext())
			{
				k=it.next();
				temp=temps.elementAt(k);
				tmp=given_Colors.get(temp);
				if(tmp!=null&&tmp>0) used_Colors.add(tmp);
			}
			for(i=8;i<=25;i++)
			{
				if(!used_Colors.contains(i))
					break;
			}
			/*there is an exception ,and coloring ends*/
			if(i>=26)
			{System.out.println("coloring failed");break;}
			/*display the coloring*/
			else 
			{	
				SregUsed=(SregUsed<i?i:SregUsed);
				given_Colors.put(temps.elementAt(reg), i);
				//Println(temps.elementAt(reg)+":"+i);
			}
		}

		/*to handle spilling*/
		int size=0;
		int a,num;
		if(n.procedure==null) num=0;
		else num=Integer.parseInt(n.procedure.f2.f0.tokenImage);
		a=(num>4?num-4:0);
		size+=a;
		SregUsed-=15;
		SregUsed=(SregUsed<0?0:SregUsed);
		SregUsed=(SregUsed<8?SregUsed:8);
		size+=SregUsed;
		int b=spilled.size();
		Iterator<Integer>lt=spilled.iterator();
		while(lt.hasNext())
		{
			reg=lt.next();
			given_Colors.put(temps.elementAt(reg), -(size++));
			//Println(temps.elementAt(reg)+":"+size);
		}
		/*calculate the size of the spilled stack*/
		status=1;
		spillArg=b+size;
		spillSize=spillArg;
		vaSize=num;
		for (i = 0; i < m; i++) 
		{
			/*the sentences which defines a variable that is never used below will be ignored*/
			if(v.elementAt(i).def>=0&&!v.elementAt(i).v_out.contains(v.elementAt(i).def)) continue;
			else
			{
				nodei = nodes.elementAt(i);
				nodei.accept(this, v.elementAt(i));
			}
		}
		/*now give our input!!*/
		/*this visit will generate real output!*/
		status=2;
		/*procedure [][][]*/
		if(n.procedure==null)
		Println("MAIN[0]["+spillSize+"]["+vaSize+"]");
		else 
		Println(n.procedure.f0.f0.tokenImage+"["+num+"]["+spillSize+"]["+vaSize+"]");	
		/*aload a4-an if put in register*/
		for(i=0;i<a;i++)
		{
			if(given_Colors.containsKey(i+4))
			{
				j=given_Colors.get(i+4);
				if(j>0)
				Println(" ALOAD"+getReg(j)+" SPILLEDARG "+(i));
			}
		}
		/*astore s1-sn*/
		for(i=a;i<a+SregUsed;i++)
		{
			Println(" ASTORE SPILLEDARG "+i+" s"+(i-a));
		}
		for (i = 0; i < m; i++) 
		{
			/*the sentences which defines a variable that is never used below will be ignored*/
			if(v.elementAt(i).def>=0&&!v.elementAt(i).v_out.contains(v.elementAt(i).def)) continue;
			else
			{
				nodei = nodes.elementAt(i);
				nodei.accept(this, v.elementAt(i));
			}
		}
		Println("END");
		return _ret;
	}
	
	/**
	 * f0 -> NoOpStmt() | ErrorStmt() | CJumpStmt() | JumpStmt() | HStoreStmt()
	 * | HLoadStmt() | MoveStmt() | PrintStmt()
	 */
	public Object visit(Stmt n, st follow) {
		return n.f0.accept(this, follow);
	}

	public String getReg(int pos)
	{
		if(pos>=4)
		{
			if(pos<8) return (" a"+(pos-4));
			if(pos<18) return (" t"+(pos-8));
			if(pos<26) return (" s"+(pos-18));
		}
		return null;
	}
	public void spill(int n)
	{
		int i,j,k,m,s,t,size;
		/*clear the node in the graph*/
		Integer tmp=n;
		Iterator<Integer> n1=matrix.elementAt(n).iterator();
		while(n1.hasNext())
		{
			j=n1.next();
			matrix.elementAt(j).remove(tmp);
		}
		matrix.elementAt(n).clear();
		/*generate new nodes*/
		int firstSpilledNode = matrix.size();
		size=Periods.elementAt(n).usedPoints.size();
		for(i=0;i<size;i++)
		{
			matrix.add(new LinkedList<Integer>());
			degree.add(0);
			s=matrix.size()-1;
			temps.add(temps.lastElement()+1);
			tempNums.put(temps.lastElement(), s);
			j=Periods.elementAt(n).usedPoints.elementAt(i);
			Iterator<Integer> m1=v.elementAt(j).v_in.iterator();
			while(m1.hasNext())
			{
				t=m1.next();
				matrix.elementAt(tempNums.get(t)).add(s);
				matrix.elementAt(s).add(tempNums.get(t));
			}
			v.elementAt(j).v_in.add(temps.lastElement());
		}
		spilledTemps.get(n)[1]=firstSpilledNode;
		spilledTemps.get(n)[0]=Periods.elementAt(n).usedPoints.firstElement();
	}