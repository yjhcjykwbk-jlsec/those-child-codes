//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;
import visitor.st;



class Period {
	int start, end;
	public Period(int a, int b) {
		start = a;
		end = b;
	}
}

class alivePeriod {
	Vector<Period> periods;
	Vector<Integer> usedPoints;
	public alivePeriod() {
		periods = new Vector<Period>();
		usedPoints=new Vector<Integer>();
	}
	public Period getP(int i) {
		return periods.elementAt(i);
	}
	public void putP(int a, int b) 
	{
		periods.add(new Period(a, b));
	}
	public boolean overLap(alivePeriod other) {
		int j = 0, sizej = other.periods.size();
		int i = 0, sizei = this.periods.size();
		Period a, b;
		while (true) {
			if (j >= sizej || i >= sizei)
				return false;
			a = this.getP(i);
			b = other.getP(j);
			if (a.end < b.start)
				i++;
			else if (b.end < a.start)
				j++;
			else
				return true;
		}
	}
}

class colorReg {
	int num;
	int degree;
	public int compare(colorReg other)
	{
		if(this.degree<other.degree) return -1;
		else if(this.degree>other.degree) return 1;
		else return 0;
	}
	public colorReg(int a,int b)
	{
		this.num=a;this.degree=b;
	}
	                           
}
class comparer implements Comparator<colorReg>
{

	@Override
	public int compare(colorReg a, colorReg b) {
		// TODO Auto-generated method stub
		if(a.degree<b.degree) return -1;
		if(a.degree>b.degree) return 1;
		return 0;
	}
}

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order. Your visitors may extend this class.
 */
public class GJDepthFirst implements GJVisitor<Object, st> {
	//
	// Auto class visitors--probably don't need to be overridden.
	//
	public HashMap<String, Integer> labels;
	HashMap<Integer,Integer> given_Colors=new HashMap<Integer,Integer>();
	boolean colors_Given;
	public Object visit(NodeList n, st argu) {
		Object _ret = null;
		int _count = 0;
		for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
			e.nextElement().accept(this, argu);
			_count++;
		}
		return _ret;
	}

	public Object visit(NodeListOptional n, st argu) {
		if (n.present()) {
			Object _ret = null;
			int _count = 0;
			for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
				e.nextElement().accept(this, argu);
				_count++;
			}
			return _ret;
		} else
			return null;
	}

	public Object visit(NodeOptional n, st argu) {
		if (n.present())
			return n.node.accept(this, argu);
		else
			return null;
	}

	public Object visit(NodeSequence n, st argu) {
		Object _ret = null;
		int _count = 0;
		for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
			e.nextElement().accept(this, argu);
			_count++;
		}
		return _ret;
	}

	public Object visit(NodeToken n, st argu) {
		return null;
	}

	//
	// User-generated visitor methods below
	//

	/**
	 * f0 -> "MAIN" f1 -> StmtList() f2 -> "END" f3 -> ( Procedure() )* f4 ->
	 * <EOF>
	 */
	public Object visit(Goal n, st argu) {
		Object _ret = null;
		System.out.println("main class");
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> Label() f1 -> "[" f2 -> IntegerLiteral() f3 -> "]" f4 -> StmtExp()
	 */
	public Object visit(Procedure n, st argu) {
		Object _ret = null;
		System.out.println(n.f0.f0.tokenImage+":");
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> "NOOP"
	 */
	public Object visit(NoOpStmt n, st v) {
		Object _ret = null;
		if(colors_Given) System.out.println(" NOOP");
		return _ret;
	}

	/**
	 * f0 -> "ERROR"
	 */
	public Object visit(ErrorStmt n, st argu) {
		Object _ret = null;
		if(colors_Given) System.out.println(" ERROR");
		return _ret;
	}

	/**
	 * f0 -> "CJUMP" f1 -> Temp() f2 -> Label()
	 */
	public Object visit(CJumpStmt n, st v) {
		int rd=Integer.parseInt(n.f1.f1.f0.tokenImage);
		if(!colors_Given)
		{
			st item = (st) v;
			item.use.add(rd);
			item.follow = n.f2.f0.tokenImage;
		}
		else  System.out.println(" CJUMP $"+given_Colors.get(rd)+" "+n.f2.f0.tokenImage);
		return null;
	}

	/**
	 * f0 -> "JUMP" f1 -> Label()
	 */
	public Object visit(JumpStmt n, st v) {
		Object _ret = null;
		if(!colors_Given){
		st item = (st) v;
		item.follow = n.f1.f0.tokenImage;
		item.jump = true;
		}
		else System.out.println(" JUMP "+n.f1.f0.tokenImage);
		return _ret;
	}

	/**
	 * f0 -> "HSTORE" f1 -> Temp() f2 -> IntegerLiteral() f3 -> Temp()
	 */
	public Object visit(HStoreStmt n, st v) {
		Object _ret = null;
		int rd=Integer.parseInt(n.f1.f1.f0.tokenImage);
		int rs=Integer.parseInt(n.f3.f1.f0.tokenImage);
		if(!colors_Given){
		st item = (st) v;
		item.use.add(rs);
		item.use.add(rd);
		}
		else System.out.println(" ASTORE $"+given_Colors.get(rd)+" "+n.f2.f0.tokenImage+" $"+given_Colors.get(rs));
		return _ret;
	}

	/**
	 * f0 -> "HLOAD" f1 -> Temp() f2 -> Temp() f3 -> IntegerLiteral()
	 */
	public Object visit(HLoadStmt n, st v) {
		Object _ret = null;
		int rd=Integer.parseInt(n.f1.f1.f0.tokenImage);
		int rs=Integer.parseInt(n.f2.f1.f0.tokenImage);
		if(!colors_Given){
		st item = (st) v;
		item.def=rd;
		item.use.add(rs);
		}
		else 
		{
			if(given_Colors.containsKey(rd))
			System.out.println(" ALOAD $"+given_Colors.get(rd)+" $"+given_Colors.get(rs)+" "+n.f3.f0.tokenImage);
		}
		return _ret;
	}

	/**
	 * f0 -> "MOVE" f1 -> Temp() f2 -> Exp()
	 */
	public Object visit(MoveStmt n, st v) {
		Object _ret = null;
		int rd=Integer.parseInt(n.f1.f1.f0.tokenImage);
		if(!colors_Given){
		st item = (st) v;
		item.def=rd;n.f2.accept(this, v);
		}
		else 
		{
			n.f2.accept(this,v);
		}
		return _ret;
	}

	/**
	 * f0 -> "PRINT" f1 -> SimpleExp()
	 */
	public Object visit(PrintStmt n, st argu) {
		Object _ret = null;
		if(colors_Given)
		{
			System.out.println(" PRINT ");
			n.f1.accept(this,argu);
		}
		return _ret;
	}

	/**
	 * f0 -> Call() | HAllocate() | BinOp() | SimpleExp()
	 */
	public Object visit(Exp n, st argu) {
		Object _ret = null;
		n.f0.accept(this, argu);
		return _ret;
	}
	/**
	 * f0 -> Temp() | IntegerLiteral() | Label()
	 */
	public Object visit(SimpleExp n, st argu) {
		Object _ret = null;
		n.f0.accept(this,argu);
		return _ret;
	}

	/**
	 * f0 -> "CALL" f1 -> SimpleExp() f2 -> "(" f3 -> ( Temp() )* f4 -> ")"
	 */
	public Object visit(Call n, st v) {
		Object _ret = null;
		if(!colors_Given) 
			{
			n.f1.accept(this,v);
			n.f3.accept(this,v);
			}
		else
		{
			for(int i=0;i<n.f3.size()&&i<4;i++)
			{
				System.out.println(" MOVE a"+i);
				n.f3.elementAt(i).accept(this, v);
			}
			for(int i=4;i<n.f3.size();i++)
			{
				System.out.println(" ASTORE  SPILLEDARG "+(i-4));
				n.f3.elementAt(i).accept(this, v);
			}
			System.out.println(" CALL ");
			n.f1.accept(this, v);
			for(int i=4;i<n.f3.size();i++)
			{
				System.out.println(" ALOAD ");
				n.f3.elementAt(i).accept(this, v);
				System.out.println(" SPILLEDARG "+(i-4));
			}
			System.out.println(" MOVE $"+given_Colors.get(v.def)+" v0");
		}
		
		return _ret;
	}

	/**
	 * f0 -> "HALLOCATE" f1 -> SimpleExp()
	 */
	public Object visit(HAllocate n, st argu) {
		Object _ret = null;
		if(colors_Given)
		{
			System.out.println(" HALLOCATE ");
		}
		n.f1.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> Operator() f1 -> Temp() f2 -> SimpleExp()
	 */
	public Object visit(BinOp n, st v) {
		Object _ret = null;
		int rs=Integer.parseInt(n.f1.f1.f0.tokenImage);
		if(!colors_Given){
		st item = (st) v;
		item.use.add(rs);
		}
		else
		{
			n.f0.accept(this, v);
			System.out.print(" $"+given_Colors.get(v.def)+" $"+given_Colors.get(rs));
		}
		n.f2.accept(this, v);
		return _ret;
	}

	/**
	 * f0 -> "LT" | "PLUS" | "MINUS" | "TIMES"
	 */
	public Object visit(Operator n, st argu) {
		Object _ret = null;
		if(colors_Given)
			{
			int s=n.f0.which;
			if(s==0) System.out.println("LT");
			else if(s==1)System.out.println("PLUS");
			else if(s==2)System.out.println("MINUS");
			else if(s==3)System.out.println("TIMES");
			}
		return _ret;
	}

	/**
	 * f0 -> "TEMP" f1 -> IntegerLiteral()
	 */
	public Object visit(Temp n, st v) {
		Object _ret = null;
		int rd=Integer.parseInt(n.f1.f0.tokenImage);
		if(!colors_Given){
		st item = (st) v;
		item.use.add(rd);
		}
		else 
		{
			System.out.println(" $"+given_Colors.get(rd));
		}
		return _ret;
	}

	/**
	 * f0 -> <INTEGER_LITERAL>
	 */
	public Object visit(IntegerLiteral n, st argu) {
		Object _ret = null;
		if(colors_Given)System.out.println(" "+n.f0.tokenImage);
		return _ret;
	}

	/**
	 * f0 -> <IDENTIFIER>
	 */
	public Object visit(Label n, st v) {
		Object _ret = null;
		if(!colors_Given){
		st item = (st) v;
		item.label = n.f0.tokenImage;
		}
		else System.out.println(" "+n.f0.tokenImage);
		return _ret;
	}
	/**
	 * f0 -> "BEGIN" f1 -> StmtList() f2 -> "RETURN" f3 -> SimpleExp() f4 ->
	 * "END"
	 */
	public Object visit(StmtExp n, st argu) {
		Object _ret = null;
		Vector<Node> nodes = n.f1.f0.nodes;
		/* the temp used in spiglet will be recorded */
		HashSet<Integer> Htemps = new HashSet<Integer>();
		Vector<Integer> temps=new Vector<Integer>();
		int i,j,m,k;
		/* every node represents a sentence ,and give it an alive analysis */
		colors_Given=false;/*if true,this visit will generate real output!*/
		m = nodes.size();
		st[] v = new st[m+1];
		for (i = 0; i <= m; i++) v[i]=new st();
		labels = new HashMap<String, Integer>();
		/*visit sentences,and initialize st[]*/
		for (i = 0; i < m; i++) 
		{
			Node nodei = nodes.elementAt(i);
			nodei.accept(this, v[i]);
			if (v[i].label != null) 
				labels.put(v[i].label, i);
			Htemps.addAll(v[i].use);
		}
		/*visit return sentence*/
		n.f3.accept(this, v[m]);
		Htemps.addAll(v[m].use);
		/**/
		temps.addAll(Htemps);
		quickSort(0,temps.size()-1,temps);
		/* fill back the (c)jump labels */
		for (i = 0; i < m; i++) 
		{
			if (v[i].follow != null)
				v[i].jumpSt = labels.get(v[i].follow);
		}
		/*get v_in for sentences*/
		boolean[] stChange = new boolean[m+1];
		for (i = m; i >= 0; i--)
			stChange[i] = true;
		boolean change=true;
		while (change) {
			change = false;
			for (i = m - 1; i >= 0; i--) {
				stChange[i] = false;
				k = v[i].jumpSt;
				if (k > 0&&stChange[k]) 
				{
					v[i].v_out.addAll(v[k].v_in);
				}
				if (!v[i].jump && stChange[i + 1])
					v[i].v_out.addAll(v[i + 1].v_in);
				/*check if changed*/
				int PreSize=v[i].v_in.size();
				v[i].v_in.addAll(v[i].v_out);
				if(v[i].def>=0) v[i].v_in.remove(v[i].def);
				v[i].v_in.addAll(v[i].use);
				int NewSize=v[i].v_in.size();
				if (NewSize>PreSize) 
				{
					change = true;stChange[i] = true;
				}
			}
		}		
		/* get alive period for temps*/
		int n1 = temps.size();
		int start, tempi;
		alivePeriod[] Periods = new alivePeriod[n1];
		for (i = 0; i < n1; i++) Periods[i]=new alivePeriod();
		for (i = 0; i < n1; i++) 
		{
			start = -1;tempi = temps.elementAt(i);
			for (j = 0; j <= m; j++) 
			{
				if (v[j].v_in.contains(tempi)){
					if (start < 0) start = j;}
				else if (start >= 0) 
				{
					Periods[i].putP(start, j - 1);start = -1;
				}
			}
			if (start >= 0) Periods[i].putP(start, j - 1);
		}
		/* now make the graph*/
		/*we can fairly color the nodes afterwards */
		LinkedList<Integer>[] matrix=new LinkedList [n1];
		for (i = 0; i < n1; i++)
			matrix[i] = new LinkedList<Integer>();
		int[] degree = new int[n1];
		HashSet<Integer> colored = new HashSet<Integer>();
		for (i = 0; i < n1; i++)
			degree[i] = 0;
		comparer comp=new comparer();
		PriorityQueue<colorReg> queue=new PriorityQueue<colorReg>(30,comp);
		for (i = 0; i < n1; i++) {
			for (j = i + 1; j < n1; j++) {
				if (Periods[i].overLap(Periods[j])) {
					matrix[i].add(j);matrix[j].add(i);degree[i]++;degree[j]++;
				}
			}
			queue.add(new colorReg(i,degree[i]));
		}
		/*make two stacks,they are spilled_Stack and colored_Stack.*/
		int reg;
		colorReg aR;
		Integer tmp;
		Stack<Integer> colored_Stack=new Stack<Integer>();
		Stack<Integer> spilled_Stack=new Stack<Integer>();
		while(!queue.isEmpty())
		{
			aR = queue.poll();
			reg=aR.num;
			if(colored.contains(reg)) continue;
			colored.add(reg);
			if(degree[reg]>16) 
			{
				spilled_Stack.add(reg);	
				ListIterator<Integer> it = matrix[reg].listIterator();  
				tmp=reg;
				while(it.hasNext())
				{
					k=it.next();
					degree[k]--;
					matrix[k].remove(tmp);
					if(!colored.contains(k)) queue.add(new colorReg(k,degree[k]));
				}
			}
			else
			{
				colored_Stack.push(reg);
				ListIterator<Integer> it = matrix[reg].listIterator();  
				while(it.hasNext())
				{
					k=it.next();
					degree[k]--;
					if(!colored.contains(k)) queue.add(new colorReg(k,degree[k]));
				}
			}
		}
		
		/*now we will deliver the colors,with the two stacks*/
		i=0;
		given_Colors.clear();
		while(!spilled_Stack.isEmpty())
		{
			reg=spilled_Stack.pop();
			given_Colors.put(temps.elementAt(reg), --i);
		}
		j=0;
		HashSet<Integer> used_Colors=new HashSet<Integer>();
		while(!colored_Stack.isEmpty())
		{
			reg=colored_Stack.pop();
			used_Colors.clear();
			ListIterator<Integer> it = matrix[reg].listIterator();  
			while(it.hasNext())
			{
				k=it.next();
				tmp=given_Colors.get(k);
				if(tmp!=null)
					used_Colors.add(tmp);
			}
			for(i=0;i<16;i++)
			{
				if(!used_Colors.contains(i))
					break;
			}
			if(i>=16)
				{System.out.println("coloring failed");break;}
			else given_Colors.put(temps.elementAt(reg), i);
		}
		
		/*now give our input!!*/
		colors_Given=true;
		for (i = 0; i < m; i++) 
		{
			Node nodei = nodes.elementAt(i);
			nodei.accept(this, v[i]);
		}
		System.out.println(" MOVE v0");
		n.f3.accept(this,argu);
		return null;
	}

	/**
	 * f0 -> ( ( Label() )? Stmt() )*
	 */
	public Object visit(StmtList n, st argu) {
		Object _ret = null;
		n.f0.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> NoOpStmt() | ErrorStmt() | CJumpStmt() | JumpStmt() | HStoreStmt()
	 * | HLoadStmt() | MoveStmt() | PrintStmt()
	 */
	public Object visit(Stmt n, st follow) {
		return n.f0.accept(this, follow);
	}

	
	void quickSort(int left, int right, Vector<Integer> s) {
		if(right > left) {
			Integer o1 = s.elementAt(right);
			int i = left - 1;
			int j = right;
			while(true) {
				while(s.elementAt(++i)<o1);
				while(j > 0)
					if(s.elementAt(--j)<=o1)
						break; // out of while
					if(i >= j) break;
					swap(i, j,s);
			}
			swap(i , right,s);
			quickSort(left,i-1,s);quickSort(i+1,right,s);
			}
		}
	void swap(int loc1,int loc2,Vector<Integer> s) 
	{
		int tmp =s.elementAt(loc1);
		s.setElementAt(s.elementAt(loc2), loc1);
		s.setElementAt(tmp, loc2);
	}
}