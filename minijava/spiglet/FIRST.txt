//
// Generated by JTB 1.3.2
//

package visitor;

import syntaxtree.*;
import types.*;
import java.util.*;

/*position to print*/

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order. Your visitors may extend this class.
 */
public class PigletVisit extends GJDepthFirst<Integer, tab> {
	//
	// Auto class visitors--probably don't need to be overridden.
	//
	//
	// User-generated visitor methods below
	//
	TypeTable types;
	ClassTable table;
	Function func;
	int reg;// current register number
	int label;
	int error;
	int noerror;
	Stack<Integer> stack;/* register number stack */

	public PigletVisit(TypeTable types) {
		this.types = types;
		stack = new Stack<Integer>();
		error=0;
	}

	/* the son-tab will be casted to its father class b */
	void typeCast(String a, String b, int castReg, tab s) {
		if (a.equals(b))
			return;/* no need for casting */
		ClassTable _table = types.getClass(a);
		ClassTable _fatherTable = types.getClass(b);
		while (_table != _fatherTable) {
			Println(("HLOAD TEMP " + (castReg) + " TEMP " + (castReg) + " " + (4 * (_table.var
					.getSize() + 1))), s);
			_table = _table.father;
		}
	}

	void Print(String s) {
		System.out.print(s);
	}

	void Println(String s, tab n) {
		System.out.println();
		for (int i = 0; i < n.t; i++)
			System.out.print(" ");
		System.out.print(s);
	}

	/**
	 * f0 -> MainClass() f1 -> ( TypeDeclaration() )* f2 -> <EOF>
	 */
	public Integer visit(Goal n, tab s) {
		n.f0.accept(this, s);
		n.f1.accept(this, s);
		return null;
	}

	/**
	 * f0 -> "class" f1 -> Identifier() f2 -> "{" f3 -> "public" f4 -> "static"
	 * f5 -> "void" f6 -> "main" f7 -> "(" f8 -> "String" f9 -> "[" f10 -> "]"
	 * f11 -> Identifier() f12 -> ")" f13 -> "{" f14 -> PrintStatement() f15 ->
	 * "}" f16 -> "}"
	 */
	public Integer visit(MainClass n, tab s) {
		reg = 19;
		label = noerror  =error= 0;
		stack.clear();
		Println(("MAIN"), s);
		n.f14.accept(this, s);
		Println(("END"), s);
		return null;
	}

	/**
	 * f0 -> ClassDeclaration() | ClassExtendsDeclaration()
	 */
	public Integer visit(TypeDeclaration n, tab s) {
		n.f0.accept(this, s);
		return null;
	}

	/**
	 * f0 -> "class" f1 -> Identifier() f2 -> "{" f3 -> ( VarDeclaration() )* f4
	 * -> ( MethodDeclaration() )* f5 -> "}"
	 */
	public Integer visit(ClassDeclaration n, tab s) {
		System.out.println();
		table = types.getClass(n.f1.f0.tokenImage);
		n.f4.accept(this, s);
		return null;
	}

	/**
	 * f0 -> "class" f1 -> Identifier() f2 -> "extends" f3 -> Identifier() f4 ->
	 * "{" f5 -> ( VarDeclaration() )* f6 -> ( MethodDeclaration() )* f7 -> "}"
	 */
	public Integer visit(ClassExtendsDeclaration n, tab s) {
		table = types.getClass(n.f1.f0.tokenImage);
		n.f6.accept(this, s);
		return null;
	}

	/**
	 * f0 -> "public" f1 -> Type() f2 -> Identifier() f3 -> "(" f4 -> (
	 * FormalParameterList() )? f5 -> ")" f6 -> "{" f7 -> ( VarDeclaration() )*
	 * f8 -> ( Statement() )* f9 -> "return" f10 -> Expression() f11 -> ";" f12
	 * -> "}"
	 */
	public Integer visit(MethodDeclaration n, tab s) {
		func = table.getFunc(n.f2.f0.tokenImage);
		int index = 0;
		int size = func.body.getSize();
		int parasize = func.para.size();
		// initialize marks in the process
		stack.clear();
		System.out.println();
		/* the name of a process */
		Println((table.name + "_" + func.name + " [" + (parasize + 1) + "]"), s);
		Println(("BEGIN"), s);
		/* initialize vars declared in function */
		n.f7.accept(this, s.add());
		reg = 19 + (func.body.getSize() - func.para.size());

		/* handle statements */
		n.f8.accept(this, s.add());

		int TEMPReg;
		stack.add(reg);
		TEMPReg = n.f10.accept(this, s.add());
		reg = stack.pop();
		Println("RETURN TEMP " + TEMPReg, s.add());
		Println(("END"), s);
		return null;
	}

	/**
	 * f0 -> Type() f1 -> Identifier() f2 -> ";"
	 */
	public Integer visit(VarDeclaration n, tab s) {
		String name = n.f1.f0.tokenImage;
		Println("MOVE TEMP " + func.getNum(name) + " 0", s);
		return null;
	}

	/**
	 * f0 -> Block() | AssignmentStatement() | ArrayAssignmentStatement() |
	 * IfStatement() | WhileStatement() | PrintStatement()
	 */
	public Integer visit(Statement n, tab s) {
		n.f0.accept(this, s);
		return null;
	}

	/**
	 * f0 -> "{" f1 -> ( Statement() )* f2 -> "}"
	 */
	public Integer visit(Block n, tab s) {
		n.f1.accept(this, s);
		return null;
	}

	/**
	 * need to judge in which scope f0 -> Identifier() f1 -> "=" f2 ->
	 * Expression() f3 -> ";"
	 */
	public Integer visit(AssignmentStatement n, tab s) {
		String name = n.f0.f0.tokenImage;
		// Integer resReg = n.f2.accept(this, s);
		int TEMPReg;
		stack.add(reg);
		TEMPReg = n.f2.accept(this, s);
		reg = stack.pop();
		int resReg = (++reg);
		if (resReg != TEMPReg)
			Println(("MOVE TEMP " + (resReg) + " TEMP " + TEMPReg), s);

		/* declared in function,and stored in register from 1 to n */
		if (func.declaredInFunc(name))
			Println("MOVE TEMP " + (func.getNum(name)) + " TEMP " + resReg, s);
		/* declared in class,and stored in memory from TEMP0 4 to 4*n */
		else {
			int leftReg = (++reg);
			ClassTable _table = table.varScopeLookUp(name);
			if (_table != table) {
				int classReg = (++reg);
				Println(("MOVE TEMP " + classReg + " TEMP 0 "), s);
				typeCast(table.name, _table.name, classReg, s);
				/*
				 * HERE JUST GIVE AN POINTER.OPPOSITE TO COMMON
				 * IDENTIFIER-VISIT!!
				 */
				Println(("MOVE TEMP " + (leftReg) + " PLUS TEMP " + classReg
						+ " " + (_table.getNum(name) * 4)), s);
			} else {
				Println(("MOVE TEMP " + (leftReg) + " PLUS TEMP 0 " + (func
						.getNum(name) * 4)),
						s);
			}

			Println("HSTORE TEMP " + leftReg + " 0 " + " TEMP " + resReg, s);
		}
		return null;
	}

	/**
	 * f0 -> Identifier() f1 -> "[" f2 -> Expression() f3 -> "]" f4 -> "=" f5 ->
	 * Expression() f6 -> ";"
	 */
	public Integer visit(ArrayAssignmentStatement n, tab s) {
		int TEMPReg;
		stack.add(reg);
		TEMPReg = n.f0.accept(this, s);
		reg = stack.pop();
		int arrayReg = (++reg);
		if (arrayReg != TEMPReg)
			Println(("MOVE TEMP " + (arrayReg) + " TEMP " + TEMPReg), s);
		/**/
		/* prevent an uninitialized array */
		/* if arrayReg<=0 error */
		int jumpReg=(++reg);
		Println(("MOVE TEMP "+jumpReg+" LT TEMP "+(arrayReg)+ " 1"),s);
		Println(("CJUMP TEMP "+jumpReg+" noerror" + (++noerror)), s);
		Println(("PRINT "+(++error)), s);
		Println(("ERROR"), s);
		Println(("noerror" + noerror + " NOOP"), s);

		/* the index will be calculated and stored in indexReg */
		stack.add(reg);
		TEMPReg = n.f2.accept(this, s);
		reg = stack.pop();
		int indexReg = (++reg);
		Println(("MOVE TEMP " + (indexReg) + " PLUS 1 TEMP " + (TEMPReg)), s);

		/* prevent a beyond array */
		int sizeReg = (++reg);
		Println(("HLOAD TEMP " + (sizeReg) + " TEMP " + (arrayReg) + " 0"), s);
		/* if indexReg<=sizeReg,right */
		Println(("MOVE TEMP "+jumpReg+" LT TEMP " + (sizeReg) + " TEMP " + (indexReg)),s);
		Println(("CJUMP TEMP "+jumpReg+" noerror" + (++noerror)), s);
		Println(("PRINT "+(++error)), s);
		Println(("ERROR"), s);
		Println(("noerror" + noerror + " NOOP"), s);

		/* calculate the right */
		stack.add(reg);
		TEMPReg = n.f5.accept(this, s);
		reg = stack.pop();
		int resReg = (++reg);/* assign this to array element */
		if (resReg != TEMPReg)
			Println(("MOVE TEMP " + (resReg) + " TEMP " + TEMPReg), s);

		/* index=4*indexReg */
		Println(("MOVE TEMP " + (indexReg) + " TIMES 4 TEMP " + (indexReg)), s);
		/* arrayReg=array element pointer */
		Println(("MOVE TEMP " + (arrayReg) + " PLUS TEMP " + (arrayReg)
				+ " TEMP " + (indexReg) + " "), s);
		Println(("HSTORE TEMP " + (arrayReg) + " 0 TEMP " + resReg), s);
		return null;
	}

	/**
	 * f0 -> "if" f1 -> "(" f2 -> Expression() f3 -> ")" f4 -> Statement() f5 ->
	 * "else" f6 -> Statement()
	 */
	public Integer visit(IfStatement n, tab s) {
		int elselabel = (++label);
		int outlabel = (++label);
		int TEMPReg;
		/* calculate the expression in f2 */
		stack.add(reg);
		TEMPReg = n.f2.accept(this, s);
		reg = stack.pop();
		int ifReg = (++reg);
		if (ifReg != TEMPReg)
			Println(("MOVE TEMP " + (ifReg) + " TEMP " + TEMPReg), s);

		/* if 0>=ifReg,goto else */
		int jumpReg=(++reg);
		Println(("MOVE TEMP "+jumpReg+" LT 0 TEMP " + (ifReg)),s);
		Println(("CJUMP TEMP " + (jumpReg) + " label" + (elselabel)),
				s);
		n.f4.accept(this, s);
		Println(("JUMP label" + (outlabel)), s);
		Println(("label" + (elselabel) + " NOOP"), s);
		n.f6.accept(this, s);
		Println(("label" + (outlabel) + " NOOP"), s);
		return null;
	}

	/**
	 * f0 -> "while" f1 -> "(" f2 -> Expression() f3 -> ")" f4 -> Statement()
	 */
	public Integer visit(WhileStatement n, tab s) {
		int iflabel = (++label);
		int outlabel = (++label);
		Println(("label" + (iflabel) + " NOOP"), s);
		int TEMPReg;
		/* calculate the expression in f2 */
		stack.add(reg);
		TEMPReg = n.f2.accept(this, s);
		reg = stack.pop();
		int ifReg = (++reg);
		if (ifReg != TEMPReg)
			Println(("MOVE TEMP " + (ifReg) + " TEMP " + TEMPReg), s);

		/* if 0>=ifReg ,break */
		int jumpReg=(++reg);
		Println(("MOVE TEMP "+jumpReg+"LT 0 TEMP " + (ifReg)),s);
		Println(("CJUMP TEMP " + (jumpReg) + " label" + (outlabel)), s);
		n.f4.accept(this, s);
		Println(("JUMP label" + iflabel), s);
		Println(("label" + (outlabel) + " NOOP"), s);
		return null;
	}

	/**
	 * f0 -> "System.out.println" f1 -> "(" f2 -> Expression() f3 -> ")" f4 ->
	 * ";"
	 */
	public Integer visit(PrintStatement n, tab s) {
		int TEMPReg;
		/* calculate the expression in f2 */
		stack.add(reg);
		TEMPReg = n.f2.accept(this, s);
		reg = stack.pop();
		Println(("PRINT TEMP " + TEMPReg), s);
		return null;
	}

	/**
	 * f0 -> AndExpression() | CompareExpression() | PLUSExpression() |
	 * MINUSExpression() | TIMESExpression() | ArrayLookup() | ArrayLength() |
	 * MessageSend() | PrimaryExpression()
	 */
	public Integer visit(Expression n, tab s) {
		int TEMPReg;
		/* calculate the expression in f0 */
		stack.add(reg);
		TEMPReg = n.f0.accept(this, s);
		reg = stack.pop();
		int resReg = (++reg);
		if (resReg != TEMPReg)
			Println(("MOVE TEMP " + (resReg) + " TEMP " + TEMPReg), s);
		/* cast type */
		if (n.cast != false) {
			typeCast(n.preType.TypeName, n.castType.TypeName, resReg, s);
		}
		return resReg;
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "&&" f2 -> PrimaryExpression()
	 */
	public Integer visit(AndExpression n, tab s) {
		int TEMPReg;
		/* calculate the expression in f0 */
		stack.add(reg);
		TEMPReg = n.f0.accept(this, s);
		reg = stack.pop();
		int resReg = (++reg);
		if (resReg != TEMPReg)
			Println(("MOVE TEMP " + (resReg) + " TEMP " + TEMPReg), s);

		int outlabel = ++label;
		/* if 0>=resReg goto outLabel */
		int jumpReg=(++reg);
		Println(("MOVE TEMP "+jumpReg+" LT 0 TEMP " + (resReg)),s);
		Println(("CJUMP TEMP " + (jumpReg) + " label" + (outlabel)), s);

		/* else */
		stack.add(reg);
		TEMPReg = n.f2.accept(this, s);
		reg = stack.pop();
		if (resReg != TEMPReg)
			Println(("MOVE TEMP " + (resReg) + " TEMP " + TEMPReg), s);

		Println(("label" + (outlabel) + " NOOP"), s);
		return resReg;
	}

/**
    * f0 -> PrimaryExpression()
    * f1 -> "<"
    * f2 -> PrimaryExpression()
    */
	public Integer visit(CompareExpression n, tab s) {
		int TEMPReg;
		/* calculate the expression in f0 */
		stack.add(reg);
		TEMPReg = n.f0.accept(this, s);
		reg = stack.pop();
		int leftReg = (++reg);
		if (leftReg != TEMPReg)
			Println(("MOVE TEMP " + (leftReg) + " TEMP " + TEMPReg), s);

		stack.add(reg);
		TEMPReg = n.f2.accept(this, s);
		reg = stack.pop();
		int rightReg = (++reg);
		if (rightReg != TEMPReg)
			Println(("MOVE TEMP " + (rightReg) + " TEMP " + TEMPReg), s);

		int resReg = (++reg);
		Println(("MOVE TEMP " + resReg + " LT TEMP " + leftReg + " TEMP " + rightReg),
				s);
		return resReg;
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "+" f2 -> PrimaryExpression()
	 */
	public Integer visit(PlusExpression n, tab s) {
		int TEMPReg;
		/* calculate the expression in f0 */
		stack.add(reg);
		TEMPReg = n.f0.accept(this, s);
		reg = stack.pop();
		int leftReg = (++reg);
		if (leftReg != TEMPReg)
			Println(("MOVE TEMP " + (leftReg) + " TEMP " + TEMPReg), s);

		stack.add(reg);
		TEMPReg = n.f2.accept(this, s);
		reg = stack.pop();
		int rightReg = (++reg);
		if (rightReg != TEMPReg)
			Println(("MOVE TEMP " + (rightReg) + " TEMP " + TEMPReg), s);

		int resReg = (++reg);
		Println(("MOVE TEMP " + resReg + " PLUS TEMP " + leftReg + " TEMP " + rightReg),
				s);
		return resReg;
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "-" f2 -> PrimaryExpression()
	 */
	public Integer visit(MinusExpression n, tab s) {
		int TEMPReg;
		/* calculate the expression in f0 */
		stack.add(reg);
		TEMPReg = n.f0.accept(this, s);
		reg = stack.pop();
		int leftReg = (++reg);
		if (leftReg != TEMPReg)
			Println(("MOVE TEMP " + (leftReg) + " TEMP " + TEMPReg), s);

		stack.add(reg);
		TEMPReg = n.f2.accept(this, s);
		reg = stack.pop();
		int rightReg = (++reg);
		if (rightReg != TEMPReg)
			Println(("MOVE TEMP " + (rightReg) + " TEMP " + TEMPReg), s);

		int resReg = (++reg);
		Println(("MOVE TEMP " + resReg + " MINUS TEMP " + leftReg + " TEMP " + rightReg),
				s);
		return resReg;
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "*" f2 -> PrimaryExpression()
	 */
	public Integer visit(TimesExpression n, tab s) {
		int TEMPReg;
		/* calculate the expression in f0 */
		stack.add(reg);
		TEMPReg = n.f0.accept(this, s);
		reg = stack.pop();
		int leftReg = (++reg);
		if (leftReg != TEMPReg)
			Println(("MOVE TEMP " + (leftReg) + " TEMP " + TEMPReg), s);

		stack.add(reg);
		TEMPReg = n.f2.accept(this, s);
		reg = stack.pop();
		int rightReg = (++reg);
		if (rightReg != TEMPReg)
			Println(("MOVE TEMP " + (rightReg) + " TEMP " + TEMPReg), s);

		int resReg = (++reg);
		Println(("MOVE TEMP " + resReg + " TIMES TEMP " + leftReg + " TEMP " + rightReg),
				s);
		return resReg;
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "[" f2 -> PrimaryExpression() f3 -> "]"
	 */
	public Integer visit(ArrayLookup n, tab s) {
		int TEMPReg;
		/* calculate the expression in f0 */
		stack.add(reg);
		TEMPReg = n.f0.accept(this, s);
		reg = stack.pop();
		int arrayReg = (++reg);
		if (arrayReg != TEMPReg)
			Println(("MOVE TEMP " + (arrayReg) + " TEMP " + TEMPReg), s);

		/* prevent uninitialized visit */
		/* if arrayReg>=1 goto no-error */
		int jumpReg=(++reg);
		Println(("MOVE TEMP "+jumpReg+" LT TEMP " + arrayReg+" 1"),s);
		Println(("CJUMP TEMP " + (jumpReg) + " noerror" + (++noerror)), s);
		Println(("PRINT "+(++error)), s);
		Println(("ERROR"), s);
		Println(("noerror" + noerror + " NOOP"), s);

		/* calculate the expression in f2 */
		stack.add(reg);
		TEMPReg = n.f2.accept(this, s);
		reg = stack.pop();
		int indexReg = (++reg);
		if (indexReg != TEMPReg)
			Println(("MOVE TEMP " + (indexReg) + " TEMP " + TEMPReg), s);
		Println(("MOVE TEMP " + (indexReg) + " PLUS TEMP " + (indexReg) + " 1"),
				s);

		int sizeReg = ++reg;
		Println(("HLOAD TEMP " + (sizeReg) + " TEMP " + (arrayReg) + " 0"), s);

		/* prevent out of range */
		/* if sizeReg>=indexReg ,goto no-error */
		Println(("MOVE TEMP " + (jumpReg) + " LT  TEMP " + sizeReg + " TEMP " + indexReg),s);
		Println(("CJUMP TEMP " + jumpReg + " noerror" + (++noerror)),
				s);
		Println(("PRINT "+(++error)), s);
		Println(("ERROR"), s);
		Println(("noerror" + noerror + " NOOP"), s);

		/* array[index] return the value */
		int resReg = ++reg;
		Println(("MOVE TEMP " + (indexReg) + " TIMES 4 TEMP " + indexReg), s);
		Println(("MOVE TEMP " + (resReg) + " PLUS TEMP " + (arrayReg)
				+ " TEMP " + indexReg), s);
		Println(("HLOAD TEMP " + (resReg) + " TEMP " + (resReg) + " 0"), s);
		return resReg;
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "." f2 -> "length"
	 */
	public Integer visit(ArrayLength n, tab s) {
		int TEMPReg;
		/* calculate the expression in f0 */
		stack.add(reg);
		TEMPReg = n.f0.accept(this, s);
		reg = stack.pop();
		int arrayReg = (++reg);
		if (arrayReg != TEMPReg)
			Println(("MOVE TEMP " + (arrayReg) + " TEMP " + TEMPReg), s);

		/* prevent uninitialized visit */
		/* if arrayReg>=1 goto no-error */
		int jumpReg=(++reg);
		Println(("MOVE TEMP " + (jumpReg) + " LT TEMP " + arrayReg + " 1"),s);
		Println(("CJUMP TEMP " + jumpReg + " noerror" + (++noerror)), s);
		Println(("PRINT "+(++error)), s);
		Println(("ERROR"), s);
		Println(("noerror" + noerror + " NOOP"), s);

		Println(("HLOAD TEMP " + (arrayReg) + " TEMP " + (arrayReg) + " 0"), s);
		return arrayReg;
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "." f2 -> Identifier() f3 -> "(" f4 -> (
	 * ExpressionList() )? f5 -> ")"
	 */
	public Integer visit(MessageSend n, tab s) {
		int TEMPReg;
		/* calculate the expression in f0 */
		stack.add(reg);
		TEMPReg = n.f0.accept(this, s);
		reg = stack.pop();
		int classReg = (++reg);
		if (classReg != TEMPReg)
			Println(("MOVE TEMP " + (classReg) + " TEMP " + TEMPReg), s);
		String classname = n.className;
		String funcname=n.f2.f0.tokenImage;
		ClassTable _table = types.getClass(classname);

		/* prevent a uninitialized CALL */
		int jumpReg=(++reg);
		Println(("MOVE TEMP " + (jumpReg) +" LT TEMP " + classReg + " 1"),s);
		Println(("CJUMP TEMP " + jumpReg + " noerror" + (++noerror)), s);
		Println(("PRINT "+(++error)), s);
		Println(("ERROR"), s);// ///
		Println(("noerror" + (noerror) + " NOOP"), s);

		int functableReg = (++reg);
		int funcReg = (++reg);
		int resReg = (++reg);
		/* store function */
		Println(("HLOAD TEMP " + (functableReg) + " TEMP " + (classReg) + " 0"),
				s);
		Println(("HLOAD TEMP " + (funcReg) + " TEMP " + (functableReg) + " " + (8 * _table.func
				.getNum(funcname))), s);
		/*store scope*/
		Println(("HLOAD TEMP " + (classReg) + " TEMP " + (functableReg) + " " + (8 * _table.func
				.getNum(funcname)+4)), s);
		int beginReg = reg;
		n.f4.accept(this, s.add());
		/* call function */
		Println(("MOVE TEMP " + resReg + " CALL TEMP " + funcReg + " ( TEMP "
				+ classReg + " "), s);
		Function _func = _table.func.get(funcname);
		for (int i = 1; i <= _func.para.size(); i++) {
			Print("TEMP " + (beginReg + i));
		}
		Print(" ) ");
		return resReg;
	}

	/**
	 * f0 -> Expression() f1 -> ( ExpressionRest() )*
	 */
	public Integer visit(ExpressionList n, tab s) {
		int TEMPReg;
		stack.add(reg);
		TEMPReg = n.f0.accept(this, s.add());
		reg = stack.pop();
		int resReg = (++reg);
		if (resReg != TEMPReg)
			Println("MOVE TEMP " + resReg + " TEMP " + TEMPReg, s);
		n.f1.accept(this, s);
		return null;
		/*
		 * int TEMPReg; Println("BEGIN", s); stack.add(reg); TEMPReg =
		 * n.f0.accept(this, s.add()); reg = stack.pop(); int resReg = (++reg);
		 * Println("RETURN TEMP " + resReg, s.add()); Println("END ", s);
		 * n.f1.accept(this, s); return null;
		 */
	}

	/**
	 * f0 -> "," f1 -> Expression()
	 */
	public Integer visit(ExpressionRest n, tab s) {
		int TEMPReg;
		stack.add(reg);
		TEMPReg = n.f1.accept(this, s.add());
		reg = stack.pop();
		int resReg = (++reg);
		if (resReg != TEMPReg)
			Println("MOVE TEMP " + resReg + " TEMP " + TEMPReg, s.add());
		return null;
	}

	/**
	 * f0 -> IntegerLiteral() | TrueLiteral() | FalseLiteral() | Identifier() |
	 * ThisExpression() | ArrayAllocationExpression() | AllocationExpression() |
	 * NotExpression() | BracketExpression()
	 */
	public Integer visit(PrimaryExpression n, tab s) {
		return n.f0.accept(this, s);
	}

	/**
	 * f0 -> <INTEGER_LITERAL>
	 */
	public Integer visit(IntegerLiteral n, tab s) {
		int resReg = (++reg);
		Println("MOVE TEMP " + (resReg) + " " + n.f0.tokenImage, s);
		return resReg;
	}

	/**
	 * f0 -> "true"
	 */
	public Integer visit(TrueLiteral n, tab s) {
		int resReg = (++reg);
		Println("MOVE TEMP " + (resReg) + " 1", s);
		return resReg;
	}

	/**
	 * f0 -> "false"
	 */
	public Integer visit(FalseLiteral n, tab s) {
		int resReg = (++reg);
		Println("MOVE TEMP " + (resReg) + " 0", s);
		return resReg;
	}

	/**
	 * f0 -> <IDENTIFIER>
	 */
	/* INCLUDING VARS EXTENDED BY ITS FATHER */
	public Integer visit(Identifier n, tab s) {
		String name = n.f0.tokenImage;
		int resReg;
		if (func.declaredInFunc(name)) {
			return func.getNum(name);
		} else {
			resReg = (++reg);
			ClassTable _table = table.varScopeLookUp(name);
			if (_table != table) {
				int classReg = (++reg);
				Println(("MOVE TEMP " + classReg + " TEMP 0 "), s);
				typeCast(table.name, _table.name, classReg, s);
				/*
				 * HERE JUST GIVE AN POINTER.OR GIVE A VALUE???IN FACT,I TAKE
				 * ASSIGNSTATEMENT TO THE VAR ASIDE ,HERE JUST GIVE AN VALUE
				 */
				Println(("HLOAD TEMP " + (resReg) + " TEMP " + classReg + " " + (_table
						.getNum(name) * 4)), s);
			} else
				Println(("HLOAD TEMP " + (resReg) + " TEMP 0 " + (func
						.getNum(name) * 4)),
						s);
		}
		return resReg;
	}

	/**
	 * f0 -> "this"
	 */
	public Integer visit(ThisExpression n, tab s) {
		return 0;
	}

	/**
	 * f0 -> "new" f1 -> "int" f2 -> "[" f3 -> Expression() f4 -> "]"
	 */
	public Integer visit(ArrayAllocationExpression n, tab s) {

		int TEMPReg;
		stack.add(reg);
		TEMPReg = n.f3.accept(this, s);
		reg = stack.pop();
		int sizeReg = (++reg);
		if (sizeReg != TEMPReg)
			Println(("MOVE TEMP " + (sizeReg) + " TEMP " + TEMPReg), s);

		/* prevent f3<0 */
		/* f3>=0 is legal */
		int jumpReg=(++reg);
		Println(("MOVE TEMP "+jumpReg+" LT TEMP " + (sizeReg) + " 0"),s);
		Println(("CJUMP TEMP " + (jumpReg) + " noerror" + (++noerror)), s);
		Println(("PRINT "+(++error)), s);
		Println(("ERROR"), s);
		Println(("noerror" + noerror + " NOOP"), s);
		/* if size==0 , there will be one word,just size itself */
		Println(("MOVE TEMP " + (sizeReg) + " PLUS 1 TEMP " + sizeReg), s);
		/* sizeReg here is the real number of words stored in memory */

		int resReg = (++reg);
		Println(("MOVE TEMP " + (resReg) + " HALLOCATE TIMES 4 TEMP " + sizeReg),
				s);
		/* sizeReg-=1,store array-size */
		Println(("MOVE TEMP " + (sizeReg) + " MINUS TEMP " + sizeReg + " 1"), s);
		Println(("HSTORE TEMP " + (resReg) + " 0 TEMP " + sizeReg), s);

		/* initialize the array elements */
		/* sizeReg+=1 */
		Println(("MOVE TEMP " + (sizeReg) + " PLUS 1 TEMP " + sizeReg), s);
		/* index=1,if index>=sizeReg goto out-label;index+=4. */
		int indexReg = (++reg);
		int storeReg = (++reg);
		int whilelabel = (++label);
		int outlabel = (++label);
		Println(("MOVE TEMP " + (indexReg) + " 1"), s);
		Println(("MOVE TEMP " + (storeReg) + " PLUS TEMP " + resReg + " 4"), s);

		Println(("label" + (whilelabel) + " NOOP"), s);
		
		Println(("MOVE TEMP "+jumpReg+" LT TEMP " + indexReg + " TEMP " + (sizeReg)),s);
		Println(("CJUMP TEMP " + (jumpReg) + " label" + (outlabel)), s);
		Println(("HSTORE TEMP " + (storeReg) + " 0 0 "), s);
		Println(("MOVE TEMP " + (indexReg) + " PLUS TEMP " + indexReg + " 1"),
				s);
		Println(("MOVE TEMP " + (storeReg) + " PLUS TEMP " + storeReg + " 4"),
				s);
		Println(("JUMP label" + (whilelabel)), s);
		Println(("label" + (outlabel) + " NOOP"), s);
		return resReg;
	}

	/* get process */
	String getProcess(ClassTable a, int i) {
		Function temp=a.func.getFunc(i);
		return temp.scope.name+"_"+temp.name;
	}

	/**
	 * f0 -> "new" f1 -> Identifier() f2 -> "(" f3 -> ")"
	 */
	public Integer visit(AllocationExpression n, tab s) {
		ClassTable _table = types.getClass(n.f1.f0.tokenImage);
		ClassTable curr = _table;
		int i;
		
		int classReg;
		int funcReg;
		int funcNum = 0;
		int varNum = 0;
		int classSize = 0;
		Function currfunc;
		stack.add(reg);
		HashMap<ClassTable,Integer> fatherRegs=new HashMap<ClassTable,Integer>();
		Stack<ClassTable> fathers=new Stack<ClassTable>();
		while(curr!=null)
    	{
    		fathers.add(curr);
    		curr=curr.father;
		}
		
		while (fathers.size()>0) {
			curr=fathers.pop();
			classReg = (++reg);
			funcReg=(++reg);
			fatherRegs.put(curr, classReg);
			funcNum = curr.func.getSize();
			varNum = curr.var.getSize();
			classSize = varNum + 2;
			Println(("MOVE TEMP " + (classReg) + " HALLOCATE " + (4 * (classSize))),
					s);
			Println(("MOVE TEMP " + (funcReg) + " HALLOCATE " + (8 * funcNum)),
					s);
			// store functions
			for (i = 0; i < funcNum; i++) {
				currfunc=curr.func.getFunc(i);
				Println(("HSTORE TEMP " + (funcReg) + " " + (8 * i) + " " + getProcess(
						curr, i)), s);
				Println(("HSTORE TEMP " + (funcReg) + " " + (8 * i+4) + " TEMP " +fatherRegs.get(currfunc.scope)), s);
			}
			Println(("HSTORE TEMP " + (classReg) + " 0 " + "TEMP " + (funcReg)),
					s);
			// initialize vars
			for (i = 1; i <= varNum; i++) {
				Println(("HSTORE TEMP " + (classReg) + " " + (4 * i) + " 0"), s);
			}

			// father pointer put into son
			if (curr.father!=null) {
				Println(("HSTORE TEMP " + (classReg) + " " +(4 * (classSize-1))+ " TEMP " + fatherRegs.get(curr.father)),
						s);
			}
		}
		reg = stack.pop();
		return fatherRegs.get(_table);
	}

	/**
	 * f0 -> "!" f1 -> Expression()
	 */
	public Integer visit(NotExpression n, tab s) {
		int TEMPReg;
		/* calculate the expression in f1 */
		stack.add(reg);
		TEMPReg = n.f1.accept(this, s);
		reg = stack.pop();
		int preReg = (++reg);
		if (preReg != TEMPReg)
			Println(("MOVE TEMP " + (preReg) + " TEMP " + TEMPReg), s);
		int resReg = (++reg);
		Println("MOVE TEMP " + resReg + " MINUS 1 TEMP " + preReg, s);
		return resReg;
	}

	/**
	 * f0 -> "(" f1 -> Expression() f2 -> ")"
	 */
	public Integer visit(BracketExpression n, tab s) {
		return n.f1.accept(this, s);
	}

}