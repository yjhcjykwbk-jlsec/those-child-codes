//
// Generated by JTB 1.3.2
//

package visitor;

import syntaxtree.*;
import types.*;
import java.util.*;
import temp.*;
/*position to print*/

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order. Your visitors may extend this class.
 */
public class PigletVisit extends GJDepthFirst<Integer,tab>{
	//
	// Auto class visitors--probably don't need to be overridden.
	//
	//
	// User-generated visitor methods below
	//
	TypeTable types;
	ClassTable table;
	Function func;
	int reg;// current register number
	int label;
	int error;
	int noerror;
	Stack<Integer> stack;/*register number stack*/
	public PigletVisit(TypeTable types) {
		this.types = types;
		stack=new Stack<Integer>();
	}
	
	/*the son-tab will be casted to its father class b*/
	void typeCast(String a,String b,int castReg,tab s)
	{
		if(a.equals(b)) return;/*no need for casting*/
		ClassTable _table = types.getClass(a);
		ClassTable _fatherTable=types.getClass(b);
		while (_table!= _fatherTable) {
			Println(("hload temp " + (castReg) + " temp "+ (castReg)+" "+(4*(_table.var.getSize()+1))),s);
			_table=_table.father;
		}
	}
	void Print(String s)
	{
		System.out.print(s);
	}
	void Println(String s,tab n)
	{
		System.out.println();
		for(int i=0;i<n.t;i++)
		System.out.print(" ");
		System.out.print(s);
	}
	/**
	 * f0 -> MainClass() f1 -> ( TypeDeclaration() )* f2 -> <EOF>
	 */
	public Integer visit(Goal n,tab s) {
		n.f0.accept(this,s);
		n.f1.accept(this,s);
		return null;
	}

	/**
	 * f0 -> "class" f1 -> Identifier() f2 -> "{" f3 -> "public" f4 -> "static"
	 * f5 -> "void" f6 -> "main" f7 -> "(" f8 -> "String" f9 -> "[" f10 -> "]"
	 * f11 -> Identifier() f12 -> ")" f13 -> "{" f14 -> PrintStatement() f15 ->
	 * "}" f16 -> "}"
	 */
	public Integer visit(MainClass n,tab s) {
		reg=1;
		label=noerror=error=0;
		stack.clear();
		Println(("main"),s);
		n.f14.accept(this,s);
		Println(("end"),s);
		return null;
	}

	/**
	 * f0 -> ClassDeclaration() | ClassExtendsDeclaration()
	 */
	public Integer visit(TypeDeclaration n,tab s) {
		n.f0.accept(this,s);
		return null;
	}

	/**
	 * f0 -> "class" f1 -> Identifier() f2 -> "{" f3 -> ( VarDeclaration() )* f4
	 * -> ( MethodDeclaration() )* f5 -> "}"
	 */
	public Integer visit(ClassDeclaration n,tab s) {
		System.out.println();
		table = types.getClass(n.f1.f0.tokenImage);
		n.f4.accept(this,s);
		return null;
	}

	/**
	 * f0 -> "class" f1 -> Identifier() f2 -> "extends" f3 -> Identifier() f4 ->
	 * "{" f5 -> ( VarDeclaration() )* f6 -> ( MethodDeclaration() )* f7 -> "}"
	 */
	public Integer visit(ClassExtendsDeclaration n,tab s) {
		table = types.getClass(n.f1.f0.tokenImage);
		n.f6.accept(this,s);
		return null;
	}

	/**
	 * f0 -> "public" f1 -> Type() f2 -> Identifier() f3 -> "(" f4 -> (
	 * FormalParameterList() )? f5 -> ")" f6 -> "{" f7 -> ( VarDeclaration() )*
	 * f8 -> ( Statement() )* f9 -> "return" f10 -> Expression() f11 -> ";" f12
	 * -> "}"
	 */
	public Integer visit(MethodDeclaration n,tab s) {
		func = table.getFunc(n.f2.f0.tokenImage);
		int index = 0;
		int size = func.body.getSize();
		int parasize = func.para.size();
		// initialize marks in the process
		error = 0;
		noerror = 0;
		label = 0;
		stack.clear();
		System.out.println();
		/*the name of a process*/
		Println((table.name + "_" + func.name + " [" + (parasize + 1)+ "]"),s);
		Println(("begin"),s);
		/*initialize vars declared in function*/
		n.f5.accept(this, s);
		reg=size+1;
		/*handle statements*/
		n.f8.accept(this,s.add());
		Println("return ",s.add());
		n.f10.accept(this,s.add(2));
		Println(("end"),s);
		return null;
	}
 
	   /**
	    * f0 -> Type()
	    * f1 -> Identifier()
	    * f2 -> ";"
	    */
	   public Integer visit(VarDeclaration n, tab s) {
	      n.f1.accept(this, s);
	      return null;
	   }

	
	/**
	 * f0 -> Block() | AssignmentStatement() | ArrayAssignmentStatement() |
	 * IfStatement() | WhileStatement() | PrintStatement()
	 */
	public Integer visit(Statement n,tab s) {
		n.f0.accept(this,s);
		return null;
	}

	/**
	 * f0 -> "{" f1 -> ( Statement() )* f2 -> "}"
	 */
	public Integer visit(Block n,tab s) {
		n.f1.accept(this,s);
		return null;
	}

	/**
	 * need to judge in which scope  f0 -> Identifier() f1 -> "=" f2
	 * -> Expression() f3 -> ";"
	 */
	public Integer visit(AssignmentStatement n,tab s) {
		String name = n.f0.f0.tokenImage;
		Integer resReg=n.f2.accept(this,s);
		/*declared in function,and stored in register from 1 to n*/
		if(func.declaredInFunc(name))
			Println("mov temp " 
					+ (func.getNum(name)) + " temp "+resReg,s);
		/*declared in class,and stored in memory from temp0 4 to 4*n*/
		else
		{
			Println("hstore temp 0 "
				+ (func.getNum(name) * 4) + " temp "+resReg,s);
		}
		return null;
	}

	/**
	 * f0 -> Identifier() f1 -> "[" f2 -> Expression() f3 -> "]" f4 -> "=" f5 ->
	 * Expression() f6 -> ";"
	 */
	public Integer visit(ArrayAssignmentStatement n,tab s) {
		int tempReg;
		stack.add(reg);
		tempReg=n.f0.accept(this,s);
		reg=stack.pop();
		int arrayReg=(++reg);
		Println(("mov temp " + (arrayReg) +" temp "+tempReg),s);
		/**/
		/* prevent an uninitialized array*/
		/*if arrayReg<=0 error*/
		Println(("cjump lt temp " + (arrayReg) + " 1 noerror" + (++noerror)),s);
		Println(("error"),s); 
		Println(("noerror"+noerror+" noop"),s); 
		
		/* the index will be calculated and stored in indexReg*/
		stack.add(reg);
		tempReg=n.f2.accept(this,s);
		reg=stack.pop();
		int indexReg=(++reg);
		Println(("mov temp " + (indexReg)+" temp "+tempReg),s);
		Println(("mov temp " + (indexReg) + " plus 1 temp " + (indexReg)),s);
		
		/*prevent a beyond array*/
		int sizeReg=(++reg);
		Println(("hload temp " + (sizeReg) + " temp " + (arrayReg) + " 0"),s);
		/*if indexReg<=sizeReg,right*/
		Println(("cjump lt temp " + (sizeReg) + " temp " + (indexReg)+ " noerror" + (++noerror)),s);
		Println(("error"),s); 
		Println(("noerror"+noerror+" noop"),s); 
		
		/*calculate the right*/
		stack.add(reg);
		tempReg=n.f5.accept(this,s);
		reg=stack.pop();
		int resReg=(++reg);/*assign this to array element*/
		Println(("mov temp " + (resReg) +" temp "+tempReg),s);
		
		/* 	index=4*indexReg*/
		Println(("mov temp " + (indexReg) + " times 4 temp " + (indexReg)),s);
		/*	arrayReg=array element pointer*/
		Println(("mov temp " + (arrayReg) + " plus temp " + (arrayReg)+" temp "+(indexReg)+" "),s);
		Println(("hstore temp " + (arrayReg) +" 0 temp "+resReg),s);
		return null;
	}

	/**
	 * f0 -> "if" f1 -> "(" f2 -> Expression() f3 -> ")" f4 -> Statement() f5 ->
	 * "else" f6 -> Statement()
	 */
	public Integer visit(IfStatement n,tab s) {
		n.outlabel = (++label);
		n.elselabel = (++label);
		int tempReg;
		/*calculate the expression in f2*/
		stack.add(reg);
		tempReg=n.f2.accept(this,s);
		reg=stack.pop();
		int ifReg=(++reg);
		Println(("mov temp " + (ifReg)+" temp "+tempReg),s);

		/*if 0>=ifReg,goto else*/
		Println(("cjump lt 0 temp " + (ifReg)+" elselabel" + (n.elselabel)),s);
		n.f4.accept(this,s);
		Println(("jump label" + (n.outlabel)),s);
		Println(("elselabel" + (n.elselabel) + " NOOP"),s);
		n.f6.accept(this,s);
		Println(("outlabel" + (n.outlabel) + " NOOP"),s);
		return null;
	}

	/**
	 * f0 -> "while" f1 -> "(" f2 -> Expression() f3 -> ")" f4 -> Statement()
	 */
	public Integer visit(WhileStatement n,tab s) {
		n.iflabel = (++label);
		n.outlabel = (++label);
		Println(("whilelabel" + (n.iflabel) + " NOOP"),s);
		int tempReg;
		/*calculate the expression in f2*/
		stack.add(reg);
		tempReg=n.f2.accept(this,s);
		reg=stack.pop();
		int ifReg=(++reg);
		Println(("mov temp " + (ifReg)+" temp "+tempReg),s);
		
		/* if 0>=ifReg ,break*/
		Println(("cjump lt 0 temp " +(ifReg)+" outlabel" + (n.outlabel)),s);
		n.f4.accept(this,s);
		Println(("jump whilelabel" + n.iflabel),s);
		Println(("outlabel" + (n.outlabel) + " NOOP"),s);
		return null;
	}

	/**
	 * f0 -> "System.out.println" f1 -> "(" f2 -> Expression() f3 -> ")" f4 ->
	 * ";"
	 */
	public Integer visit(PrintStatement n,tab s) {
		int tempReg;
		/*calculate the expression in f2*/
		stack.add(reg);
		tempReg=n.f2.accept(this,s);
		reg=stack.pop();
		int resReg=(++reg);
		Println(("mov temp " + (resReg)+" temp "+tempReg),s);
		Println(("print temp "+resReg),s);
		return null;
	}

	/**
	 * f0 -> AndExpression() | CompareExpression() | PlusExpression() |
	 * MinusExpression() | TimesExpression() | ArrayLookup() | ArrayLength() |
	 * MessageSend() | PrimaryExpression()
	 */
	public Integer visit(Expression n,tab s) {
		int tempReg;
		/*calculate the expression in f2*/
		stack.add(reg);
		tempReg=n.f0.accept(this,s);
		reg=stack.pop();
		int resReg=(++reg);
		Println(("mov temp " + (resReg)+" temp "+tempReg),s);
		/*cast type*/
		if(n.cast!=false)
		{
			typeCast(n.preType.TypeName,n.castType.TypeName,resReg,s);
		}
		return resReg;
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "&&" f2 -> PrimaryExpression()
	 */
	public Integer visit(AndExpression n,tab s) {
		int tempReg;
		/*calculate the expression in f0*/
		stack.add(reg);
		tempReg=n.f0.accept(this,s);
		reg=stack.pop();
		int resReg=(++reg);
		Println(("mov temp " + (resReg)+" temp "+tempReg),s);
		
		int outlabel = ++label;
		/*if 0>=resReg goto outLabel*/
		Println(("cjump lt 0 temp " + (resReg) +" outlabel" + (outlabel)),s.add());
		
		/*else*/
		stack.add(reg);
		tempReg=n.f2.accept(this,s);
		reg=stack.pop();
		Println(("mov temp " + (resReg)+" temp "+tempReg),s);
		
		Println(("outlabel" + (outlabel) + " NOOP"),s.add());
		return resReg;
	}

/**
    * f0 -> PrimaryExpression()
    * f1 -> "<"
    * f2 -> PrimaryExpression()
    */
	public Integer visit(CompareExpression n,tab s) {
		int tempReg;
		/*calculate the expression in f0*/
		stack.add(reg);
		tempReg=n.f0.accept(this,s);
		reg=stack.pop();
		int leftReg=(++reg);
		Println(("mov temp " + (leftReg)+" temp "+tempReg),s);
		
		stack.add(reg);
		tempReg=n.f0.accept(this,s);
		reg=stack.pop();
		int rightReg=(++reg);
		Println(("mov temp " + (rightReg)+" temp "+tempReg),s);
		
		int resReg=(++reg);
		Println(("mov temp "+resReg+" lt temp "+leftReg+" temp "+rightReg),s);
		return resReg;
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "+" f2 -> PrimaryExpression()
	 */
	public Integer visit(PlusExpression n,tab s) {
		int tempReg;
		/*calculate the expression in f0*/
		stack.add(reg);
		tempReg=n.f0.accept(this,s);
		reg=stack.pop();
		int leftReg=(++reg);
		Println(("mov temp " + (leftReg)+" temp "+tempReg),s);
		
		stack.add(reg);
		tempReg=n.f0.accept(this,s);
		reg=stack.pop();
		int rightReg=(++reg);
		Println(("mov temp " + (rightReg)+" temp "+tempReg),s);
		
		int resReg=(++reg);
		Println(("mov temp "+resReg+" plus temp "+leftReg+" temp "+rightReg),s);
		return resReg;
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "-" f2 -> PrimaryExpression()
	 */
	public Integer visit(MinusExpression n,tab s) {
		int tempReg;
		/*calculate the expression in f0*/
		stack.add(reg);
		tempReg=n.f0.accept(this,s);
		reg=stack.pop();
		int leftReg=(++reg);
		Println(("mov temp " + (leftReg)+" temp "+tempReg),s);
		
		stack.add(reg);
		tempReg=n.f0.accept(this,s);
		reg=stack.pop();
		int rightReg=(++reg);
		Println(("mov temp " + (rightReg)+" temp "+tempReg),s);
		
		int resReg=(++reg);
		Println(("mov temp "+resReg+" minus temp "+leftReg+" temp "+rightReg),s);
		return resReg;
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "*" f2 -> PrimaryExpression()
	 */
	public Integer visit(TimesExpression n,tab s) {
		int tempReg;
		/*calculate the expression in f0*/
		stack.add(reg);
		tempReg=n.f0.accept(this,s);
		reg=stack.pop();
		int leftReg=(++reg);
		Println(("mov temp " + (leftReg)+" temp "+tempReg),s);
		
		stack.add(reg);
		tempReg=n.f0.accept(this,s);
		reg=stack.pop();
		int rightReg=(++reg);
		Println(("mov temp " + (rightReg)+" temp "+tempReg),s);
		
		int resReg=(++reg);
		Println(("mov temp "+resReg+" times temp "+leftReg+" temp "+rightReg),s);
		return resReg;
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "[" f2 -> PrimaryExpression() f3 -> "]"
	 */
	public Integer visit(ArrayLookup n,tab s) {
		int tempReg;
		/*calculate the expression in f0*/
		stack.add(reg);
		tempReg=n.f0.accept(this,s);
		reg=stack.pop();
		int arrayReg=(++reg);
		Println(("mov temp " + (arrayReg)+" temp "+tempReg),s);
		
		/*prevent uninitialized visit*/
		/*if arrayReg>=1 goto no-error*/
		Println(("cjump lt temp "+ arrayReg+ " 1 noerror"+(++noerror)),s);
		Println(("error"),s.add());
		Println(("noerror"+noerror+" noop"),s.add());
		
		/*calculate the expression in f2*/
		stack.add(reg);
		tempReg=n.f2.accept(this,s);
		reg=stack.pop();
		int indexReg=(++reg);
		Println(("mov temp " + (indexReg)+" temp "+tempReg),s);
		Println(("mov temp " + (indexReg)+" plus temp "+(indexReg)+" 1"),s);
		
		int sizeReg =++reg;
		Println(("hload temp " + (sizeReg)+" temp "+(arrayReg)+" 0"),s);
		
		/*prevent out of range*/
		/*if sizeReg>=indexReg ,goto no-error*/
		Println(("cjump lt  temp "+ sizeReg+ " temp "+indexReg+" noerror"+(++noerror)),s.add());
		Println(("error"),s.add());
		Println(("noerror"+noerror+" noop"),s.add());
	
		/*array[index] return the value*/
		int resReg =++reg;
		Println(("mov temp " + (resReg)+" plus temp "+(arrayReg)+" times 4 temp "+indexReg),s.add());
		Println(("hload temp " + (resReg)+" temp "+(resReg)+" 0"),s);
		return resReg;
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "." f2 -> "length"
	 */
	public Integer visit(ArrayLength n,tab s) {
		int tempReg;
		/*calculate the expression in f0*/
		stack.add(reg);
		tempReg=n.f0.accept(this,s);
		reg=stack.pop();
		int arrayReg=(++reg);
		Println(("mov temp " + (arrayReg)+" temp "+tempReg),s);
		
		/*prevent uninitialized visit*/
		/*if arrayReg>=1 goto no-error*/
		Println(("cjump lt temp "+ arrayReg+ " 1 noerror"+(++noerror)),s);
		Println(("error"),s.add());
		Println(("noerror"+noerror+" noop"),s.add());
		
		Println(("hload temp " + (arrayReg) + " temp " + (arrayReg) + " 0"),s);
		return arrayReg;
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "." f2 -> Identifier() f3 -> "(" f4 -> (
	 * ExpressionList() )? f5 -> ")"
	 */
	public Integer visit(MessageSend n,tab s) {
		int tempReg;
		/*calculate the expression in f0*/
		stack.add(reg);
		tempReg=n.f0.accept(this,s);
		reg=stack.pop();
		int classReg=(++reg);
		Println(("mov temp " + (classReg)+" temp "+tempReg),s);
		
		String preClassName=n.className;
		String name=n.f2.f0.tokenImage;
		ClassTable _table = types.getClass(preClassName);
		ClassTable _castTable=_table;
		while (_castTable.func.get(name) == null) {
			_castTable=_castTable.father;
		}
		typeCast(_table.name,_castTable.name,classReg,s);
		
		/*prevent a uninitialized call*/
		Println(("cjump lt temp "+classReg+" 1 noerror"+(++noerror)),s);
		Println(("error"),s);
		Println(("noerror"+(noerror)+" noop"),s);

		int functableReg = (++reg);
		int funcReg = (++reg);
		/*store function*/
		Println(("hload temp " + (functableReg) + " temp "+(classReg)+" 0"),s);
		Println(("hload temp " + (funcReg) + " temp "+(functableReg)+" "+(4*_table.func.getNum(name))),s);
		
		Println(("mov temp "+classReg+" call temp "+funcReg+" ( temp "+classReg+" "),s);
		n.f4.accept(this,s.add());
		Print(" ) ");
		return classReg;
	}

	/**
	 * f0 -> Expression() f1 -> ( ExpressionRest() )*
	 */
	public Integer visit(ExpressionList n,tab s) {
		int tempReg;
		Println("begin",s);
		stack.add(reg);
		tempReg=n.f0.accept(this,s.add());
		reg=stack.pop();
		int resReg=(++reg);
		Println("return temp "+resReg,s);
		Println("end\n",s.add());
		n.f1.accept(this,s);
		return null;
	}

	/**
	 * f0 -> "," f1 -> Expression()
	 */
	public Integer visit(ExpressionRest n,tab s) {
		int tempReg;
		Println("begin",s);
		stack.add(reg);
		tempReg=n.f1.accept(this,s.add());
		reg=stack.pop();
		int resReg=(++reg);
		Println("return temp "+resReg,s);
		Println("end\n",s.add());
		return null;
	}

	/**
	 * f0 -> IntegerLiteral() | TrueLiteral() | FalseLiteral() | Identifier() |
	 * ThisExpression() | ArrayAllocationExpression() | AllocationExpression() |
	 * NotExpression() | BracketExpression()
	 */
	public Integer visit(PrimaryExpression n,tab s) {
		return n.f0.accept(this,s);
	}

	/**
	 * f0 -> <INTEGER_LITERAL>
	 */
	public Integer visit(IntegerLiteral n,tab s) {
		Println("mov temp "+(++reg)+" "+n.f0.tokenImage,s);
		return reg;
	}

	/**
	 * f0 -> "true"
	 */
	public Integer visit(TrueLiteral n,tab s) {
		Println("mov temp "+(++reg)+" 1",s);
		return reg;
	}

	/**
	 * f0 -> "false"
	 */
	public Integer visit(FalseLiteral n,tab s) {
		Println("mov temp "+(++reg)+" 0",s);
		return reg;
	}

	/**
	 * f0 -> <IDENTIFIER>
	 */
	public Integer visit(Identifier n,tab s) {
		String name=n.f0.tokenImage;
		int resReg;
		if (func.declaredInFunc(name)) 
		{
			resReg=func.getNum(name);
		}
		else {
			resReg=(++reg);
			Println(("hload temp " + (resReg) + " temp 0 " + (func.getNum(name) * 4) ),s);
		}
		return resReg;
	}

	/**
	 * f0 -> "this"
	 */
	public Integer visit(ThisExpression n,tab s) {
		return 0;
	}

	/**
	 * f0 -> "new" f1 -> "int" f2 -> "[" f3 -> Expression() f4 -> "]"
	 */
	public Integer visit(ArrayAllocationExpression n,tab s) {
		
		int tempReg;
		stack.add(reg);
		tempReg=n.f3.accept(this,s);
		reg=stack.pop();
		int sizeReg = (++reg);
		Println(("mov temp " + (sizeReg)+" temp "+tempReg),s);
		
		/*prevent f3<0*/
		/*f3>=0 is legal*/
		Println(("cjump lt temp " + (sizeReg) + " 0 noerror"+ (++noerror)),s.add());
		Println(("error"),s.add());
		Println(("noerror"+noerror+" noop"),s.add());
		/*if size==0 , there will be one word,just size itself*/
		Println(("mov temp " + (sizeReg)+" plus 1 temp "+sizeReg),s.add());
		/*sizeReg here is the real number of words stored in memory*/
		
		int resReg = (++reg);
		Println(("mov temp " + (resReg) + " hallocate times 4 temp "+ sizeReg),s.add());
		/*sizeReg-=1,store array-size*/
		Println(("mov temp " + (sizeReg)+" minus temp "+sizeReg+" 1"),s.add());
		Println(("store temp " + (resReg)+" 0 temp "+sizeReg),s.add());
		
		/*initialize the array elements*/
		/*sizeReg+=1*/
		Println(("mov temp " + (sizeReg)+" plus 1 temp "+sizeReg),s.add());
		/*index=1,if index>=sizeReg goto out-label;index+=4.*/
		int indexReg = (++reg);
		int storeReg =(++reg);
		int whilelabel=(++label);
		int outlabel=(++label);
		Println(("mov temp " + (indexReg)+" 1"),s.add());
		Println(("mov temp " + (storeReg)+" plus temp "+resReg+" 4"),s.add());
		
		Println(("whilelabel"+(whilelabel)+" noop"),s.add());
		Println(("cjump temp "+indexReg+" temp " + (sizeReg)+" outlabel"+(outlabel)),s.add());
		Println(("store temp " + (storeReg)+" 0 0 "),s.add());
		Println(("mov temp " + (indexReg)+" plus temp "+indexReg+" 1"),s.add());
		Println(("mov temp " + (storeReg)+" plus temp "+storeReg+" 4"),s.add());
		Println(("cjump whilelabel"+(whilelabel)),s.add());
		Println(("outlabel"+(outlabel)+" noop"),s.add());
		return resReg;
	}

	/*get process*/
	String getProcess(ClassTable a, int i) {
		return a.name + "_" + a.func.getFunc(i);
	}

	/**
	 * f0 -> "new" f1 -> Identifier() f2 -> "(" f3 -> ")"
	 */
	public Integer visit(AllocationExpression n,tab s) {
		table = types.getClass(n.f1.f0.tokenImage);
		ClassTable curr = table;
		int i;
		int resReg = (++reg);
		int classReg = (++reg);
		int funcReg = (++reg);
		int classStoreReg = (++reg);

		int funcNum = 0;
		int varNum = 0;
		int classSize = 0;
		int fatherSize = 0;
		while (curr != null) {
			funcNum = curr.func.getSize();
			varNum = curr.var.getSize();
			classSize = varNum + 2;
			Println(("mov temp " + (classReg) + " hallocate "+ (4 * (classSize))),s.add());
			Println(("mov temp " + (funcReg) + " hallocate "+ (4 * funcNum)),s.add());
			// store functions
			for (i = 0; i < funcNum; i++) {
				Println(("hstore temp " + (funcReg) + " " + (4 * i)+ " " + getProcess(curr, i)),s.add());
			}
			Println(("hstore temp " + (classReg) + " 0 " + "temp "+ (funcReg)),s.add());

			// initialize vars
			for (i = 0; i < varNum; i++) {
				Println(("hstore temp " + (classReg) + " "+ (4 * (i + 1)) + " 0"),s.add());
			}

			// to return resReg
			if (curr == table) {
				Println(("mov temp " + resReg + " temp " + classReg),s.add());
			}
			// put class pointer(reg) into memory
			else {
				Println(("hstore temp " + classStoreReg + " 0 "+ "temp " + classReg),s.add());
			}
			// copy father-reg
			if (curr.father != null) {
				Println(("mov temp " + classStoreReg + " plus "+ "temp " + classReg + " " + (4 * (classSize - 1))),s.add());
				curr = curr.father;
			}
			// father is null
			else {
				Println(("hstore temp " + classReg + " "+ (4 * (classSize - 1)) + " 0 "),s.add());
				break;
			}
		}
		return resReg;
	}

	/**
	 * f0 -> "!" f1 -> Expression()
	 */
	public Integer visit(NotExpression n,tab s) {
		int tempReg;
		/*calculate the expression in f1*/
		stack.add(reg);
		tempReg=n.f1.accept(this,s);
		reg=stack.pop();
		int preReg=(++reg);
		Println(("mov temp " + (preReg)+" temp "+tempReg),s);
		int resReg=(++reg);
		Println("mov temp "+resReg+" minus 1 temp "+preReg,s);
		return resReg;
	}

	/**
	 * f0 -> "(" f1 -> Expression() f2 -> ")"
	 */
	public Integer visit(BracketExpression n,tab s) {
		return n.f1.accept(this,s);
	}

}
