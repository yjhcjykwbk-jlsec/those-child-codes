//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;
import visitor.st;

class Period {
	int start, end;
	public Period(int a, int b) {
		start = a;
		end = b;
	}
}

class alivePeriod {
	Vector<Period> periods;

	public alivePeriod() {
		periods = new Vector<Period>();
	}

	public Period getP(int i) {
		return periods.elementAt(i);
	}

	public boolean overLap(alivePeriod other) {
		int j = 0, sizej = other.periods.size();
		int i = 0, sizei = this.periods.size();
		Period a, b;
		while (true) {
			if (j >= sizej || i >= sizei)
				return false;
			a = this.getP(i);
			b = other.getP(j);
			if (a.end < b.start)
				i++;
			else if (b.end < a.start)
				j++;
			else
				return true;
		}
	}

	public void putP(int a, int b) {
		periods.add(new Period(a, b));
	}
}

class colorReg {
	int num;
	int degree;
	public int compare(colorReg other)
	{
		if(this.degree<other.degree) return -1;
		else if(this.degree>other.degree) return 1;
		else return 0;
	}
	public colorReg(int a,int b)
	{
		this.num=a;this.degree=b;
	}
	                           
}

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order. Your visitors may extend this class.
 */
public class GJDepthFirst implements GJVisitor<Object, st> {
	//
	// Auto class visitors--probably don't need to be overridden.
	//
	public HashMap<String, Integer> labels;

	public Object visit(NodeList n, st argu) {
		Object _ret = null;
		int _count = 0;
		for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
			e.nextElement().accept(this, argu);
			_count++;
		}
		return _ret;
	}

	public Object visit(NodeListOptional n, st argu) {
		if (n.present()) {
			Object _ret = null;
			int _count = 0;
			for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
				e.nextElement().accept(this, argu);
				_count++;
			}
			return _ret;
		} else
			return null;
	}

	public Object visit(NodeOptional n, st argu) {
		if (n.present())
			return n.node.accept(this, argu);
		else
			return null;
	}

	public Object visit(NodeSequence n, st argu) {
		Object _ret = null;
		int _count = 0;
		for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
			e.nextElement().accept(this, argu);
			_count++;
		}
		return _ret;
	}

	public Object visit(NodeToken n, st argu) {
		return null;
	}

	//
	// User-generated visitor methods below
	//

	/**
	 * f0 -> "MAIN" f1 -> StmtList() f2 -> "END" f3 -> ( Procedure() )* f4 ->
	 * <EOF>
	 */
	public Object visit(Goal n, st argu) {
		Object _ret = null;
		System.out.println("main class");
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> Label() f1 -> "[" f2 -> IntegerLiteral() f3 -> "]" f4 -> StmtExp()
	 */
	public Object visit(Procedure n, st argu) {
		Object _ret = null;
		System.out.println(n.f0.f0.tokenImage+":");
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> "NOOP"
	 */
	public Object visit(NoOpStmt n, st v) {
		Object _ret = null;
		return _ret;
	}

	/**
	 * f0 -> "ERROR"
	 */
	public Object visit(ErrorStmt n, st argu) {
		Object _ret = null;
		n.f0.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> "CJUMP" f1 -> Temp() f2 -> Label()
	 */
	public Object visit(CJumpStmt n, st v) {
		st item = (st) v;
		item.use.add(n.f1.f1.f0.kind);
		item.follow = n.f2.f0.tokenImage;
		return null;
	}

	/**
	 * f0 -> "JUMP" f1 -> Label()
	 */
	public Object visit(JumpStmt n, st v) {
		Object _ret = null;
		st item = (st) v;
		item.follow = n.f1.f0.tokenImage;
		item.jump = true;
		return _ret;
	}

	/**
	 * f0 -> "HSTORE" f1 -> Temp() f2 -> IntegerLiteral() f3 -> Temp()
	 */
	public Object visit(HStoreStmt n, st v) {
		Object _ret = null;
		st item = (st) v;
		item.use.add(Integer.parseInt(n.f1.f1.f0.tokenImage));// ///////////////////
		item.use.add(Integer.parseInt(n.f3.f1.f0.tokenImage));
		return _ret;
	}

	/**
	 * f0 -> "HLOAD" f1 -> Temp() f2 -> Temp() f3 -> IntegerLiteral()
	 */
	public Object visit(HLoadStmt n, st v) {
		Object _ret = null;
		st item = (st) v;
		item.def.add(Integer.parseInt(n.f1.f1.f0.tokenImage));
		item.use.add(Integer.parseInt(n.f2.f1.f0.tokenImage));
		return _ret;
	}

	/**
	 * f0 -> "MOVE" f1 -> Temp() f2 -> Exp()
	 */
	public Object visit(MoveStmt n, st v) {
		Object _ret = null;
		st item = (st) v;
		item.def.add(Integer.parseInt(n.f1.f1.f0.tokenImage));
		n.f2.accept(this, v);
		return _ret;
	}

	/**
	 * f0 -> "PRINT" f1 -> SimpleExp()
	 */
	public Object visit(PrintStmt n, st argu) {
		Object _ret = null;
		n.f1.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> Call() | HAllocate() | BinOp() | SimpleExp()
	 */
	public Object visit(Exp n, st argu) {
		Object _ret = null;
		n.f0.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> "BEGIN" f1 -> StmtList() f2 -> "RETURN" f3 -> SimpleExp() f4 ->
	 * "END"
	 */
	public Object visit(StmtExp n, st argu) {
		Object _ret = null;
		n.f0.accept(this, argu);
		Vector<Node> nodes = n.f1.f0.nodes;
		/* the temp used in spiglet will be recorded */
		HashSet<Integer> Htemps = new HashSet<Integer>();
		Vector<Integer> temps=new Vector<Integer>();
		/* every node represents a sentence */
		/* and give it an alive analysis */
		int m = nodes.size();
		st[] v = new st[m+1];
		for (int i = 0; i <= m; i++) v[i]=new st();
		labels = new HashMap<String, Integer>();
		for (int i = 0; i < m; i++) {
			Node nodei = nodes.elementAt(i);
			nodei.accept(this, v[i]);
			if (v[i].label != null) {
				labels.put(v[i].label, i);
			}
			Htemps.addAll(v[i].use);
		}
		n.f3.accept(this, v[m]);
		Htemps.addAll(v[m].use);
		temps.addAll(Htemps);
		
		/* fill back the (c)jump labels */
		for (int i = 0; i < m; i++) {
			if (v[i].follow != null)
				v[i].jumpSt = labels.get(v[i].follow);
		}
		boolean[] stChange = new boolean[m+1];
		for (int i = m; i >= 0; i--)
			stChange[i] = true;
		Integer k;
		boolean change=true;
		while (change) {
			change = false;
			for (int i = m - 1; i >= 0; i--) {
				stChange[i] = false;
				k = v[i].jumpSt;
				if (k > 0) {
					if (stChange[k])
						v[i].v_out.addAll(v[k].v_in);
				}
				if (!v[i].jump && stChange[i + 1])
					v[i].v_out.addAll(v[i + 1].v_in);
				int PreSize=v[i].v_in.size();
				//newin = new ArrayList<Integer>(v[i].v_out);
				v[i].v_in.addAll(v[i].v_out);
				v[i].v_in.removeAll(v[i].def);
				v[i].v_in.addAll(v[i].use);
				int NewSize=v[i].v_in.size();
				if (NewSize>PreSize) {
					change = true;
					stChange[i] = true;
				}
			}
		}		
		/* alive period will be recorded */
		int n1 = temps.size();
		int start, tempi;
		alivePeriod[] Periods = new alivePeriod[n1];
		for (int i = 0; i < n1; i++) Periods[i]=new alivePeriod();
		for (int i = 0; i < n1; i++) {
			start = -1;
			tempi = temps.elementAt(i);
			for (int j = 0; j <= m; j++) {
				if (v[j].v_in.contains(tempi) || v[j].def.contains(tempi)) {
					if (start < 0)
						start = j;
				} else {
					if (start > 0) {
						Periods[i].putP(start, j - 1);
						start = -1;
					}
				}
			}
		}
		for(int i=0;i<n1;i++) 
			{
				alivePeriod s=Periods[i];
				System.out.print("temp "+temps.elementAt(i)+":");
				for (int j=0;j<s.periods.size();j++)
				{
					Period t=s.periods.elementAt(j);
					System.out.print(t.start+","+t.end+"¡¡");
				}
				System.out.println();
			}
		/* now we will deliver the registers */
		/* a graph */
		boolean[][] matrix = new boolean[n1][n1];
		for (int i = 0; i < n1; i++)
			for (int j = i + 1; j < n1; j++)
				matrix[i][j] = false;
		int[] degree = new int[n1];
		for (int i = 0; i < n1; i++)
			degree[i] = 0;
		//PriorityQueue<colorReg> queue = new PriorityQueue<colorReg>();
		for (int i = 0; i < n1; i++) {
			for (int j = i + 1; j < n1; j++) {
				if (Periods[i].overLap(Periods[j])) {
					matrix[i][j] = true;
					degree[i]++;
				}
				//queue.add(new colorReg(i,degree[i]));
			}
		}
		/* color */
		
		n.f3.accept(this, argu);
		return null;
	}

	/**
	 * f0 -> ( ( Label() )? Stmt() )*
	 */
	public Object visit(StmtList n, st argu) {
		Object _ret = null;
		n.f0.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> NoOpStmt() | ErrorStmt() | CJumpStmt() | JumpStmt() | HStoreStmt()
	 * | HLoadStmt() | MoveStmt() | PrintStmt()
	 */
	public Object visit(Stmt n, st follow) {
		return n.f0.accept(this, follow);
	}

	/**
	 * f0 -> Temp() | IntegerLiteral() | Label()
	 */
	public Object visit(SimpleExp n, st argu) {
		Object _ret = null;
		n.f0.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> "CALL" f1 -> SimpleExp() f2 -> "(" f3 -> ( Temp() )* f4 -> ")"
	 */
	public Object visit(Call n, st argu) {
		Object _ret = null;
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> "HALLOCATE" f1 -> SimpleExp()
	 */
	public Object visit(HAllocate n, st argu) {
		Object _ret = null;
		n.f1.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> Operator() f1 -> Temp() f2 -> SimpleExp()
	 */
	public Object visit(BinOp n, st v) {
		Object _ret = null;
		st item = (st) v;
		item.use.add(Integer.parseInt(n.f1.f1.f0.tokenImage));
		n.f2.accept(this, v);
		return _ret;
	}

	/**
	 * f0 -> "LT" | "PLUS" | "MINUS" | "TIMES"
	 */
	public Object visit(Operator n, st argu) {
		Object _ret = null;
		n.f0.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> "TEMP" f1 -> IntegerLiteral()
	 */
	public Object visit(Temp n, st v) {
		Object _ret = null;
		st item = (st) v;
		item.use.add(Integer.parseInt(n.f1.f0.tokenImage));
		return _ret;
	}

	/**
	 * f0 -> <INTEGER_LITERAL>
	 */
	public Object visit(IntegerLiteral n, st argu) {
		Object _ret = null;
		n.f0.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> <IDENTIFIER>
	 */
	public Object visit(Label n, st v) {
		Object _ret = null;
		st item = (st) v;
		item.label = n.f0.tokenImage;
		return _ret;
	}

}
