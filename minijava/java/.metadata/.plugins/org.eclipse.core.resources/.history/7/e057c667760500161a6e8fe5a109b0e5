//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import types.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class pigletvisit extends DepthFirstVisitor {
   //
   // Auto class visitors--probably don't need to be overridden.
   //
   //
   // User-generated visitor methods below
   //
   TypeTable types;
   ClassTable table;
   FunctionTable funcs;
   Function func;
   int reg;//寄存器编号
   int label;
   int error;
   Stack<Integer> stack;//寄存器分配栈
   Stack<Integer> labels;
   
   /**
    * f0 -> MainClass()
    * f1 -> ( TypeDeclaration() )*
    * f2 -> <EOF>
    */
   public void visit(Goal n) {
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
   }
   public pigletvisit(TypeTable types)
   {
	   stack=new Stack<Integer>();
	   labels=new Stack<Integer>();
	   this.types=types;
   }
   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> "public"
    * f4 -> "static"
    * f5 -> "void"
    * f6 -> "main"
    * f7 -> "("
    * f8 -> "String"
    * f9 -> "["
    * f10 -> "]"
    * f11 -> Identifier()
    * f12 -> ")"
    * f13 -> "{"
    * f14 -> PrintStatement()
    * f15 -> "}"
    * f16 -> "}"
    */
   public void visit(MainClass n) {
      System.out.println("begin");
      table=types.getClass(n.f1.f0.tokenImage);
      System.out.println("move temp "+table.reg+" 0");
      n.f14.accept(this);
      System.out.println("end");
   }

   /**
    * f0 -> ClassDeclaration()
    *       | ClassExtendsDeclaration()
    */
   public void visit(TypeDeclaration n) {
      n.f0.accept(this);
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> ( VarDeclaration() )*
    * f4 -> ( MethodDeclaration() )*
    * f5 -> "}"
    */
   public void visit(ClassDeclaration n) {
      table=types.getClass(n.f1.f0.tokenImage);
      n.f4.accept(this);
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "extends"
    * f3 -> Identifier()
    * f4 -> "{"
    * f5 -> ( VarDeclaration() )*
    * f6 -> ( MethodDeclaration() )*
    * f7 -> "}"
    */
   public void visit(ClassExtendsDeclaration n) {
	   table=types.getClass(n.f1.f0.tokenImage);
	   n.f6.accept(this);
   }
   /**
    * f0 -> "public"
    * f1 -> Type()
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( FormalParameterList() )?
    * f5 -> ")"
    * f6 -> "{"
    * f7 -> ( VarDeclaration() )*
    * f8 -> ( Statement() )*
    * f9 -> "return"
    * f10 -> Expression()
    * f11 -> ";"
    * f12 -> "}"
    */
   public void visit(MethodDeclaration n) {
	  func=table.getFunc(n.f2.f0.tokenImage);
	  int index=0;
      int size=func.body.getSize();
      int parasize=func.para.size();
      if(parasize>19) parasize=19;
      //initialize marks in the process
      func.reg=reg=20;
      error=0;
      label=0;
      labels.clear();
      stack.clear();
	  System.out.println(table.name+"_"+func.name+" ["+(parasize+1)+"]");//[<=20]
	  System.out.println("begin");
	  System.out.println("mov temp "+reg+" hallocate "+(4*size));//分配内存参数表
	  //vars will stored in memory
      for(index=0;index<size;index++)
      {
    	  System.out.println("hstore temp "+reg+" "+(index*4)+" 0");
      }
      n.f8.accept(this);
      System.out.print("return ");
      n.f10.accept(this);
      System.out.println("end");
   }

   /**
    * f0 -> FormalParameter()
    * f1 -> ( FormalParameterRest() )*
    */
   public void visit(FormalParameterList n) {
      
   }
   /**
    * f0 -> ","
    * f1 -> FormalParameter()
    */
   public void visit(FormalParameterRest n) {
      
   }

   /**
    * f0 -> Block()
    *       | AssignmentStatement()
    *       | ArrayAssignmentStatement()
    *       | IfStatement()
    *       | WhileStatement()
    *       | PrintStatement()
    */
   public void visit(Statement n) {
      n.f0.accept(this);
   }

   /**
    * f0 -> "{"
    * f1 -> ( Statement() )*
    * f2 -> "}"
    */
   public void visit(Block n) {   
      n.f1.accept(this);
   }

   /**need to judge in which scope :paralist?
    * f0 -> Identifier()
    * f1 -> "="
    * f2 -> Expression()
    * f3 -> ";"
    */
   public void visit(AssignmentStatement n) 
   {
	   String name=n.f0.f0.tokenImage;
	   
	   int scope;
	   //assign a var stored in function
	   if(func.declaredInFunc(name))
	   {
		   scope=func.reg;
	   }
	   //assign a var stored in class ,or say ,temp0 . here temp0 is the real diaoyongzhe
	   else
	   {
		   scope=0;
	   }
	   System.out.println("hstore temp "+scope+" "+(func.getNum(name)*4)+" ");
	   n.f2.accept(this);
   }

   /**
    * f0 -> Identifier()
    * f1 -> "["
    * f2 -> Expression()
    * f3 -> "]"
    * f4 -> "="
    * f5 -> Expression()
    * f6 -> ";"
    */
   public void visit(ArrayAssignmentStatement n) {
	   String name=n.f0.f0.tokenImage;
	   int scope;
	   //assign a var stored in function
	   if(func.declaredInFunc(name))
	   {
		   scope=func.reg;
	   }
	   //assign a var stored in class ,or say ,temp0 . here temp0 is the real diaoyongzhe
	   else
	   {
		   scope=0;
	   }
	   System.out.println("hload temp "+(++reg)+" temp "+(scope)+(func.getNum(name)*4)+" ");
	   //prevent an uninitialized array
	   System.out.println("cjump lt temp "+(reg)+" 1 error"+(++error));
	   //the index will be calculated and stored in reg+1
	   System.out.println("mov temp "+(++reg)+" ");
	   n.f2.accept(this);
	   reg--;
	   //prevent a beyond array
	   //hstore size
	   System.out.println("hload temp "+(reg+2)+" temp "+reg+" 0");
	   //if beyond?
	   System.out.println("cjump lt temp "+(reg+1)+" temp "+(reg+2)+" error"+(++error));
	   //index=4*reg2+4
	   System.out.println("mov temp "+(reg)+" plus temp "+(reg)+" 4");
	   System.out.println("mov temp "+(reg)+" plus temp "+reg+" times temp "+(reg+1)+" 4 ");
	   System.out.println("hstore temp "+(reg)+" ");
	   n.f5.accept(this);
	   //array errors should be handled
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    * f5 -> "else"
    * f6 -> Statement()
    */
   public void visit(IfStatement n) {
      //System.out.println("")
	   //how to deal with the if in an efficient way
	  n.outlabel=(++label);
	  n.iflabel=(++label);
	  n.elselabel=(++label);
	                                   //labels.add(label);
	  //to handle jump to else-label in the expression!?????????????????????
	  System.out.println("mov temp "+(++reg));
	  n.f2.accept(this);
	  System.out.println("cjump lt 0 temp "+reg+" label"+(n.elselabel));
	  
                                        //labels.pop();
      System.out.println("label"+(n.iflabel)+" NOOP");
      n.f4.accept(this);
      System.out.println("jump label"+(n.outlabel));
      System.out.println("label"+(n.elselabel)+" NOOP");
      n.f6.accept(this);
      System.out.println("label"+(n.outlabel)+" NOOP");
   }

   /**
    * f0 -> "while"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public void visit(WhileStatement n) {
	  n.iflabel=(++label);
	  n.outlabel=(++label);
	  System.out.println("label"+(n.iflabel)+" NOOP");
	  System.out.println("mov temp "+(++reg));
      n.f2.accept(this);
      //if reg==0 break
      System.out.println("cjump lt 0 temp "+" label"+(n.outlabel));
      n.f4.accept(this);
      System.out.println("jump label"+n.iflabel);
      System.out.println("label"+(n.outlabel)+" NOOP");
   }

   /**
    * f0 -> "System.out.println"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> ";"
    */
   public void visit(PrintStatement n) {
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      n.f3.accept(this);
      n.f4.accept(this);
   }

   /**
    * f0 -> AndExpression()
    *       | CompareExpression()
    *       | PlusExpression()
    *       | MinusExpression()
    *       | TimesExpression()
    *       | ArrayLookup()
    *       | ArrayLength()
    *       | MessageSend()
    *       | PrimaryExpression()
    */
   public void visit(Expression n) {
	   	System.out.println("begin");
	   	stack.add(reg);
	   	n.f0.accept(this);
	   	reg=stack.pop();
		System.out.println("end");
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "&&"
    * f2 -> PrimaryExpression()
    */
   public void visit(AndExpression n) {
	  int outlabel=++label;
	  stack.add(reg);
	  System.out.println("begin");
	  System.out.println("mov temp "+(++reg));
      n.f0.accept(this);
      System.out.println("cjump lt 0 temp "+reg+" label"+(outlabel));
      System.out.println("mov temp "+(reg));
      n.f2.accept(this);
      System.out.println("label"+(outlabel)+" NOOP");
      System.out.println("return temp "+reg);
      System.out.println("end");
      reg=stack.pop();
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "<"
    * f2 -> PrimaryExpression()
    */
   public void visit(CompareExpression n) {
	  System.out.println("lt ");
      n.f0.accept(this);
      n.f2.accept(this);
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "+"
    * f2 -> PrimaryExpression()
    */
   public void visit(PlusExpression n) {
	  System.out.println("plus ");
      n.f0.accept(this);
      n.f2.accept(this);
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "-"
    * f2 -> PrimaryExpression()
    */
   public void visit(MinusExpression n) {
	   System.out.println("minus ");
	   n.f0.accept(this);
	   n.f2.accept(this);
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "*"
    * f2 -> PrimaryExpression()
    */
   public void visit(TimesExpression n) {
	   System.out.println("times ");
	   n.f0.accept(this);
	   n.f2.accept(this);
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "["
    * f2 -> PrimaryExpression()
    * f3 -> "]"
    */
   public void visit(ArrayLookup n) {
	  //prevent array problems???
	  int reg1,reg2;
	  System.out.println("begin");
	  reg1=++reg;
	  System.out.println("mov temp "+(reg1));
      n.f0.accept(this);
      //reg1 = A0
      System.out.println("mov temp "+(reg1)+" plus temp "+(reg1)+" 4");
      
      reg2=++reg;
      System.out.println("mov temp "+(reg2));
      n.f2.accept(this);
      System.out.println("mov temp "+(reg1)+"plus temp "+(reg1)+" times 4 temp "+reg2);
      System.out.println("return temp "+reg1);
      System.out.println("end");
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> "length"
    */
   public void visit(ArrayLength n) {
	  System.out.println("begin");
	  int reg1=++reg;
	  System.out.println("mov temp "+(reg1));
      n.f0.accept(this);
      //if the array is uninitialized
      System.out.println("cjump lt temp "+reg1+" 0 error"+(++error));
      System.out.println("hload temp "+(reg1)+" temp "+(reg1)+" 0");
      System.out.println("return temp "+reg1);
      System.out.println("end");
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( ExpressionList() )?
    * f5 -> ")"
    */
   public void visit(MessageSend n) {
	  int objectReg=(++reg);//duotai!!!!
	  ClassTable _table=types.getClass(n.className);
	  while(_table.func.get(n.f2.f0.tokenImage)==null)
	  {
		  
	  }
	  System.out.println("mov temp "+(objectReg));
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      n.f3.accept(this);
      n.f4.accept(this);
      n.f5.accept(this);
   }

   /**
    * f0 -> Expression()
    * f1 -> ( ExpressionRest() )*
    */
   public void visit(ExpressionList n) {
      n.f0.accept(this);
      n.f1.accept(this);
   }

   /**
    * f0 -> ","
    * f1 -> Expression()
    */
   public void visit(ExpressionRest n) {
      n.f0.accept(this);
      n.f1.accept(this);
   }

   /**
    * f0 -> IntegerLiteral()
    *       | TrueLiteral()
    *       | FalseLiteral()
    *       | Identifier()
    *       | ThisExpression()
    *       | ArrayAllocationExpression()
    *       | AllocationExpression()
    *       | NotExpression()
    *       | BracketExpression()
    */
   public void visit(PrimaryExpression n) {
      n.f0.accept(this);
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public void visit(IntegerLiteral n) {
	   System.out.println(n.toString());
   }

   /**
    * f0 -> "true"
    */
   public void visit(TrueLiteral n) {
	   System.out.println("true");
   }

   /**
    * f0 -> "false"
    */
   public void visit(FalseLiteral n) {
	   System.out.println("false");
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public void visit(Identifier n) {
      n.f0.accept(this);
   }

   /**
    * f0 -> "this"
    */
   public void visit(ThisExpression n) {
      n.f0.accept(this);
   }

   /**
    * f0 -> "new"
    * f1 -> "int"
    * f2 -> "["
    * f3 -> Expression()
    * f4 -> "]"
    */
   public void visit(ArrayAllocationExpression n) {
	  int sizeReg=(++reg);
	  System.out.println("begin");
	  System.out.println("mov temp "+(sizeReg));
      n.f3.accept(this);
      System.out.println("cjump lt temp "+(sizeReg)+" 0 "+"error"+(++error));
      System.out.println("mov temp "+(++reg)+" hallocate times 4 temp "+sizeReg);
      System.out.println("error"+(error));//wrong///
      System.out.println("return temp "+reg);
      System.out.println("end");
   }
   /////get process
   String getProcess(ClassTable a,int i)
   {
	   return a.name+"_"+a.func.getFunc(i);
   }
   /**
    * f0 -> "new"
    * f1 -> Identifier()
    * f2 -> "("
    * f3 -> ")"
    */
   public void visit(AllocationExpression n) {
       System.out.println("begin");
       table=types.getClass(n.f1.f0.tokenImage);
       ClassTable curr=table;
       int i;
       int resReg=(++reg);
       int classReg=(++reg);
       int funcReg=(++reg);
       int classStoreReg=(++reg);
       
       int funcNum=0;
       int varNum=0;
       int classSize=0;
       int fatherSize=0;
       while(curr!=null)
       {
    	   funcNum=curr.func.getSize();
    	   varNum=curr.var.getSize();
    	   classSize=varNum+2;
    	   System.out.println("mov temp "+(classReg)+" hallocate "+(4*(classSize))+" 0 ");
    	   System.out.println("mov temp "+(funcReg)+" hallocate "+(4*funcNum));
    	   //store functions
    	   for(i=0;i<funcNum;i++)
    	   {
    		   System.out.println("store temp "+(funcReg)+" "+(4*i)+" "+getProcess(curr,i));
    	   }
    	   System.out.println("store temp "+(classReg)+" 0 "+"temp "+(funcReg));
    	   
    	   //store vars
    	   for(i=0;i<varNum;i++)
    	   {
    		   System.out.println("store temp "+(funcReg)+" "+(4*(i+1))+" "+curr.var.getVar(i)); 
    	   }
    	   
    	   //to return resreg
    	   if(curr==table)
    	   {
    		   System.out.println("mov temp "+resReg+" temp "+classReg);
    	   }
    	   //put class pointer(reg) into memory
    	   else
    	   {
    		   System.out.println("store temp "+classStoreReg+" 0 "+"temp "+classReg);
    	   }
    	   //copy father-reg
    	   if(curr.father!=null)
    	   {
    		   System.out.println("mov temp "+classStoreReg+" plus "+"temp "+classReg+" "+(4*(classSize-1)));
    		   curr=curr.father;
    	   }
    	   //father is null
    	   else
    	   {
    		   System.out.println("hstore temp "+classReg+" "+(4*(classSize-1))+" 0 ");
    		   break;
    	   } 
       }
       System.out.println("return temp "+resReg);
       System.out.println("end");
   }

   /**
    * f0 -> "!"
    * f1 -> Expression()
    */
   public void visit(NotExpression n) {
      System.out.println("begin");
      n.f1.accept(this);/////////1 则・0 好好看看指令表
      System.out.println("not expression");////
      System.out.println("end");
   }

   /**
    * f0 -> "("
    * f1 -> Expression()
    * f2 -> ")"
    */
   public void visit(BracketExpression n) {
      n.f1.accept(this);
   }

}
