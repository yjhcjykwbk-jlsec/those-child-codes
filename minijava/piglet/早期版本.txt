//
// Generated by JTB 1.3.2
//

package visitor;

import syntaxtree.*;
import types.*;
import java.util.*;
import temp.*;
/*position to print*/
class tab extends Object
{
	public int t;
	public tab()
	{
		t=0;
	}
}

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order. Your visitors may extend this class.
 */
public class PigletVisit extends GJDepthFirst<Integer,tab>{
	//
	// Auto class visitors--probably don't need to be overridden.
	//
	//
	// User-generated visitor methods below
	//
	TypeTable types;
	ClassTable table;
	Function func;
	int reg;// current register number
	int label;
	int error;
	int noerror;
	/*the son-tab will be casted to its father class b*/
	void typeCast(String a,String b,int castReg)
	{
		if(a.equals(b)) return;/*no need for casting*/
		ClassTable _table = types.getClass(a);
		ClassTable _fatherTable=types.getClass(b);
		while (_table!= _fatherTable) {
			System.out.println("hload temp " + (castReg) + " temp "
					+ (castReg)+" "+(4*(_table.var.getSize()+1)));
			_table=_table.father;
		}
	}
	void Print(String s,tab n)
	{
		for(int i=0;i<n.t;i++)
		System.out.print(" ");
		System.out.print(s);
	}
	void Println(String s,tab n)
	{
		for(int i=0;i<n.t;i++)
		System.out.print(" ");
		System.out.println(s);
	}
	/**
	 * f0 -> MainClass() f1 -> ( TypeDeclaration() )* f2 -> <EOF>
	 */
	public Integer visit(Goal n,tab s) {
		n.f0.accept(this,s);
		n.f1.accept(this,s);
		return null;
	}

	public PigletVisit(TypeTable types) {
		this.types = types;
	}

	/**
	 * f0 -> "class" f1 -> Identifier() f2 -> "{" f3 -> "public" f4 -> "static"
	 * f5 -> "void" f6 -> "main" f7 -> "(" f8 -> "String" f9 -> "[" f10 -> "]"
	 * f11 -> Identifier() f12 -> ")" f13 -> "{" f14 -> PrintStatement() f15 ->
	 * "}" f16 -> "}"
	 */
	public Integer visit(MainClass n,tab s) {
		reg=1;
		label=noerror=error=0;
		Println(("main"),s);
		n.f14.accept(this,s);
		System.out.println("end");
		return null;
	}

	/**
	 * f0 -> ClassDeclaration() | ClassExtendsDeclaration()
	 */
	public Integer visit(TypeDeclaration n,tab s) {
		n.f0.accept(this,s);
		return null;
	}

	/**
	 * f0 -> "class" f1 -> Identifier() f2 -> "{" f3 -> ( VarDeclaration() )* f4
	 * -> ( MethodDeclaration() )* f5 -> "}"
	 */
	public Integer visit(ClassDeclaration n,tab s) {
		System.out.println();
		table = types.getClass(n.f1.f0.tokenImage);
		n.f4.accept(this,s);
		return null;
	}

	/**
	 * f0 -> "class" f1 -> Identifier() f2 -> "extends" f3 -> Identifier() f4 ->
	 * "{" f5 -> ( VarDeclaration() )* f6 -> ( MethodDeclaration() )* f7 -> "}"
	 */
	public Integer visit(ClassExtendsDeclaration n,tab s) {
		table = types.getClass(n.f1.f0.tokenImage);
		n.f6.accept(this,s);
		return null;
	}

	/**
	 * f0 -> "public" f1 -> Type() f2 -> Identifier() f3 -> "(" f4 -> (
	 * FormalParameterList() )? f5 -> ")" f6 -> "{" f7 -> ( VarDeclaration() )*
	 * f8 -> ( Statement() )* f9 -> "return" f10 -> Expression() f11 -> ";" f12
	 * -> "}"
	 */
	public Integer visit(MethodDeclaration n,tab s) {
		func = table.getFunc(n.f2.f0.tokenImage);
		int index = 0;
		int size = func.body.getSize();
		int parasize = func.para.size();
		// initialize marks in the process
		error = 0;
		noerror = 0;
		label = 0;
		System.out.println();
		/*the name of a process*/
		System.out.println(table.name + "_" + func.name + " [" + (parasize + 1)
				+ "]");
		System.out.println("begin");
		/*prevent a uninitialized call*/
		System.out.println("cjump lt 0 temp 0 noerror"+(++noerror));
		System.out.println("error");
		System.out.println("noerror"+(noerror)+" noop");
		
		/*store vars declared in function*/
		/*initialize them*/
		for (index = parasize+1; index <= size; index++) {
			System.out.println("mov temp " + index + " 0");
		}
		reg=size+1;
		/*handle statements*/
		n.f8.accept(this,s);
		System.out.print("return ");
		n.f10.accept(this,s);
		System.out.println("end");
		return null;
	}

	/**
	 * f0 -> Block() | AssignmentStatement() | ArrayAssignmentStatement() |
	 * IfStatement() | WhileStatement() | PrintStatement()
	 */
	public Integer visit(Statement n,tab s) {
		n.f0.accept(this,s);
		return null;
	}

	/**
	 * f0 -> "{" f1 -> ( Statement() )* f2 -> "}"
	 */
	public Integer visit(Block n,tab s) {
		n.f1.accept(this,s);
		return null;
	}

	/**
	 * need to judge in which scope  f0 -> Identifier() f1 -> "=" f2
	 * -> Expression() f3 -> ";"
	 */
	public Integer visit(AssignmentStatement n,tab s) {
		String name = n.f0.f0.tokenImage;
		/*declared in function,and stored in register from 1 to n*/
		if(func.declaredInFunc(name))
			System.out.print("mov temp " 
					+ (func.getNum(name)) + " ");
		/*declared in class,and stored in memory from temp0 4 to 4*n*/
		else
		{
			System.out.print("hstore temp 0 "
				+ (func.getNum(name) * 4) + " ");
		}
		n.f2.accept(this,s);
		return null;
	}

	/**
	 * f0 -> Identifier() f1 -> "[" f2 -> Expression() f3 -> "]" f4 -> "=" f5 ->
	 * Expression() f6 -> ";"
	 */
	public Integer visit(ArrayAssignmentStatement n,tab s) {
		int arrayReg=(++reg);
		// assign a var stored in function
		System.out.print("mov temp " + (arrayReg) +" ");
		n.f0.accept(this,s);
		/**/
		// prevent an uninitialized array
		//if arrayReg<=0 error
		System.out.println("cjump lt temp " + (arrayReg) + " noerror" + (++noerror));
		System.out.println("error"); 
		System.out.println("noerror"+noerror+" noop"); 
		
		// the index will be calculated and stored in reg+1
		int indexReg=(++reg);
		System.out.print("mov temp " + (indexReg)+" ");
		n.f2.accept(this,s);
		// prevent a beyond array
		int sizeReg=(++reg);
		System.out.println("hload temp " + (sizeReg) + " temp " + (arrayReg) + " 0");
		// if indexReg<sizeReg,jump
		System.out.println("cjump lt temp " + (indexReg) + " temp " + (sizeReg)
				+ " noerror" + (++noerror));
		System.out.println("error"); 
		System.out.println("noerror"+noerror+" noop"); 
		// 	index=4*indexReg+4
		System.out.println("mov temp " + (indexReg) + " plus 1 temp " + (indexReg));
		System.out.println("mov temp " + (indexReg) + " times 4 temp " + (indexReg));
		//	arrayReg=array element pointer
		System.out.println("mov temp " + (arrayReg) + " plus temp " + (arrayReg)+" temp "+(indexReg)+" ");
		System.out.println("hstore temp " + (arrayReg) +" 0 ");
		n.f5.accept(this,s);
		return null;
	}

	/**
	 * f0 -> "if" f1 -> "(" f2 -> Expression() f3 -> ")" f4 -> Statement() f5 ->
	 * "else" f6 -> Statement()
	 */
	public Integer visit(IfStatement n,tab s) {
		n.outlabel = (++label);
		n.iflabel = (++label);
		n.elselabel = (++label);
		int ifReg=(++reg);
		System.out.print("mov temp " + (ifReg)+" ");
		n.f2.accept(this,s);
		/*if ifReg<1 ,goto else*/
		System.out.println("cjump lt  temp " + (ifReg)+" 1" + " elselabel" + (n.elselabel));
		System.out.println("iflabel" + (n.iflabel) + " NOOP");
		n.f4.accept(this,s);
		System.out.println("jump label" + (n.outlabel));
		System.out.println("elselabel" + (n.elselabel) + " NOOP");
		n.f6.accept(this,s);
		System.out.println("outlabel" + (n.outlabel) + " NOOP");
		return null;
	}

	/**
	 * f0 -> "while" f1 -> "(" f2 -> Expression() f3 -> ")" f4 -> Statement()
	 */
	public Integer visit(WhileStatement n,tab s) {
		n.iflabel = (++label);
		n.outlabel = (++label);
		int ifReg=(++reg);
		System.out.println("whilelabel" + (n.iflabel) + " NOOP");
		System.out.print("mov temp " + (ifReg)+" ");
		n.f2.accept(this,s);
		// if ifReg<1 ,break
		System.out.println("cjump lt  temp " +(ifReg)+" 0 "+ "outlabel" + (n.outlabel));
		n.f4.accept(this,s);
		System.out.println("jump whilelabel" + n.iflabel);
		System.out.println("outlabel" + (n.outlabel) + " NOOP");
		return null;
	}

	/**
	 * f0 -> "System.out.println" f1 -> "(" f2 -> Expression() f3 -> ")" f4 ->
	 * ";"
	 */
	public Integer visit(PrintStatement n,tab s) {
		System.out.print("print ");
		n.f2.accept(this,s);
		return null;
	}

	/**
	 * f0 -> AndExpression() | CompareExpression() | PlusExpression() |
	 * MinusExpression() | TimesExpression() | ArrayLookup() | ArrayLength() |
	 * MessageSend() | PrimaryExpression()
	 */
	public Integer visit(Expression n,tab s) {
		if(n.cast!=false)
		{
			System.out.println("");
			System.out.println("begin");
			System.out.print("mov temp "+(++reg)+" ");
			n.f0.accept(this,s);
			typeCast(n.preType.TypeName,n.castType.TypeName,reg);
			System.out.println("return temp "+reg);
			System.out.println("end");
		}
		else n.f0.accept(this,s);
		return null;
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "&&" f2 -> PrimaryExpression()
	 */
	public Integer visit(AndExpression n,tab s) {
		int outlabel = ++label;
		int resReg=(++reg);
		//stack.add(reg);
		System.out.println("");
		System.out.println("begin");
		System.out.print("mov temp " + (resReg)+" ");
		n.f0.accept(this,s);
		System.out.println("cjump lt temp " + (resReg) +" 1"+ " andlabel" + (outlabel));
		System.out.print("mov temp " + (resReg)+" ");
		n.f2.accept(this,s);
		System.out.println("andlabel" + (outlabel) + " NOOP");
		System.out.println("return temp " + (resReg));
		System.out.println("end");
		return null;
	}

/**
    * f0 -> PrimaryExpression()
    * f1 -> "<"
    * f2 -> PrimaryExpression()
    */
	public Integer visit(CompareExpression n,tab s) {
		System.out.println("lt ");
		n.f0.accept(this,s);
		n.f2.accept(this,s);
		return null;
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "+" f2 -> PrimaryExpression()
	 */
	public Integer visit(PlusExpression n,tab s) {
		System.out.println("plus ");
		n.f0.accept(this,s);
		n.f2.accept(this,s);
		return null;
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "-" f2 -> PrimaryExpression()
	 */
	public Integer visit(MinusExpression n,tab s) {
		System.out.println("minus ");
		n.f0.accept(this,s);
		n.f2.accept(this,s);
		return null;
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "*" f2 -> PrimaryExpression()
	 */
	public Integer visit(TimesExpression n,tab s) {
		System.out.println("times ");
		n.f0.accept(this,s);
		n.f2.accept(this,s);
		return null;
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "[" f2 -> PrimaryExpression() f3 -> "]"
	 */
	public Integer visit(ArrayLookup n,tab s) {
		// prevent array problems???
		int arrayReg=(++reg); 
		System.out.println("");
		System.out.println("begin");
		System.out.print("mov temp " + (arrayReg)+" ");
		n.f0.accept(this,s);
		/*prevent uninitialized visit*/
		System.out.println("cjump lt 0 temp "+ arrayReg+ " noerror"+(++noerror));
		System.out.println("error");
		System.out.println("noerror"+noerror+" noop");
		
		int indexReg =++reg;
		System.out.print("mov temp " + (indexReg)+" ");
		n.f2.accept(this,s);
		int sizeReg =++reg;
		System.out.println("hload temp " + (sizeReg)+" temp "+(arrayReg)+" 0");
		/*prevent out of range*/
		System.out.println("cjump lt  temp "+ indexReg+ " temp "+sizeReg+" noerror"+(++noerror));
		System.out.println("error");
		System.out.println("noerror"+noerror+" noop");
		
		System.out.println("mov temp " + (indexReg)+" plus temp "+(indexReg)+" 1");
		System.out.println("mov temp " + (indexReg)+ " times 4 temp "+(indexReg));
		System.out.println("mov temp " + (arrayReg)+" plus temp "+(arrayReg)+" temp "+indexReg);
		System.out.println("return temp " + arrayReg);
		System.out.println("end");
		return null;
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "." f2 -> "length"
	 */
	public Integer visit(ArrayLength n,tab s) {
		System.out.println("");
		System.out.println("begin");
		int arrayReg = ++reg;
		System.out.print("mov temp " + (arrayReg)+" ");
		n.f0.accept(this,s);
		// if the array is uninitialized
		System.out.println("cjump lt 0 temp " + (arrayReg) + " noerror" + (++noerror));
		System.out.println("error");
		System.out.println("noerror"+noerror+" noop");
		
		System.out.println("hload temp " + (arrayReg) + " temp " + (arrayReg) + " 0");
		System.out.println("return temp " + (arrayReg));
		System.out.println("end");
		return null;
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "." f2 -> Identifier() f3 -> "(" f4 -> (
	 * ExpressionList() )? f5 -> ")"
	 */
	public Integer visit(MessageSend n,tab s) {
		int tabReg = (++reg);// duotai!!!!
		int functableReg = (++reg);
		int funcReg = (++reg);
		String name=n.f2.f0.tokenImage;
		System.out.println("call");
		System.out.println("begin");
		System.out.print("mov temp " + (tabReg)+" ");
		n.f0.accept(this,s);
		ClassTable _table = types.getClass(n.className);
		ClassTable _castTable=_table;
		while (_castTable.func.get(name) == null) {
			_castTable=_castTable.father;
		}
		typeCast(_table.name,_castTable.name,tabReg);
		System.out.println("hload temp " + (functableReg) + " temp "+(tabReg)+" 0");
		System.out.println("hload temp " + (funcReg) + " temp "+(functableReg)+" "+(4*_table.func.getNum(name)));
		System.out.println("return temp "+funcReg);//func-reg store the address of process 
		System.out.println("end");
		System.out.print("( temp "+tabReg+" ");
		n.f4.accept(this,s);
		System.out.println(" ) ");
		return null;
	}

	/**
	 * f0 -> Expression() f1 -> ( ExpressionRest() )*
	 */
	public Integer visit(ExpressionList n,tab s) {
		n.f0.accept(this,s);
		System.out.println(" ");
		n.f1.accept(this,s);
		return null;
	}

	/**
	 * f0 -> "," f1 -> Expression()
	 */
	public Integer visit(ExpressionRest n,tab s) {
		n.f1.accept(this,s);
		System.out.println(" ");
		return null;
	}

	/**
	 * f0 -> IntegerLiteral() | TrueLiteral() | FalseLiteral() | Identifier() |
	 * ThisExpression() | ArrayAllocationExpression() | AllocationExpression() |
	 * NotExpression() | BracketExpression()
	 */
	public Integer visit(PrimaryExpression n,tab s) {
		n.f0.accept(this,s);
		return null;
	}

	/**
	 * f0 -> <INTEGER_LITERAL>
	 */
	public Integer visit(IntegerLiteral n,tab s) {
		System.out.println(n.f0.tokenImage);
		return null;
	}

	/**
	 * f0 -> "true"
	 */
	public Integer visit(TrueLiteral n,tab s) {
		System.out.println("1");
		return null;
	}

	/**
	 * f0 -> "false"
	 */
	public Integer visit(FalseLiteral n,tab s) {
		System.out.println("0");
		return null;
	}

	/**
	 * f0 -> <IDENTIFIER>
	 */
	public Integer visit(Identifier n,tab s) {
		String name=n.f0.tokenImage;
		int resReg=(++reg);
		if (func.declaredInFunc(name)) 
		{
			System.out.print(" temp " + (func.getNum(name)));
		}
		else {
			System.out.println("");
			System.out.println("begin");
			System.out.println("hload temp " + (resReg) + " temp 0 " 
					+ (func.getNum(name) * 4) );
			System.out.println("return temp "+resReg);
			System.out.println("end");
		}
		return null;
	}

	/**
	 * f0 -> "this"
	 */
	public Integer visit(ThisExpression n,tab s) {
		System.out.print(" temp 0");
		return null;
	}

	/**
	 * f0 -> "new" f1 -> "int" f2 -> "[" f3 -> Expression() f4 -> "]"
	 */
	public Integer visit(ArrayAllocationExpression n,tab s) {
		int sizeReg = (++reg);
		int resReg = (++reg);
		System.out.println("");
		System.out.println("begin");
		System.out.print("mov temp " + (sizeReg)+" ");
		n.f3.accept(this,s);
		/*prevent f3<0*/
		/*f3==0 is legal*/
		System.out.println("cjump lt temp " + (sizeReg) + " 0 error"
				+ (++error));
		System.out.println("jump noerror"+(++noerror));
		System.out.println("error"+error+" noop");
		System.out.println("error");
		System.out.println("noerror"+noerror+" noop");
		
		System.out.println("mov temp " + (sizeReg)+" plus 1 temp "+sizeReg);
		System.out.println("mov temp " + (resReg) + " hallocate times 4 temp "
				+ sizeReg);
		System.out.println("return temp " + resReg);
		System.out.println("end");
		return null;
	}

	/*get process*/
	String getProcess(ClassTable a, int i) {
		return a.name + "_" + a.func.getFunc(i);
	}

	/**
	 * f0 -> "new" f1 -> Identifier() f2 -> "(" f3 -> ")"
	 */
	public Integer visit(AllocationExpression n,tab s) {
		System.out.println("");
		System.out.println("begin");
		table = types.getClass(n.f1.f0.tokenImage);
		ClassTable curr = table;
		int i;
		int resReg = (++reg);
		int classReg = (++reg);
		int funcReg = (++reg);
		int classStoreReg = (++reg);

		int funcNum = 0;
		int varNum = 0;
		int classSize = 0;
		int fatherSize = 0;
		while (curr != null) {
			funcNum = curr.func.getSize();
			varNum = curr.var.getSize();
			classSize = varNum + 2;
			System.out.println("mov temp " + (classReg) + " hallocate "
					+ (4 * (classSize)));
			System.out.println("mov temp " + (funcReg) + " hallocate "
					+ (4 * funcNum));
			// store functions
			for (i = 0; i < funcNum; i++) {
				System.out.println("store temp " + (funcReg) + " " + (4 * i)
						+ " " + getProcess(curr, i));
			}
			System.out.println("store temp " + (classReg) + " 0 " + "temp "
					+ (funcReg));

			// store vars
			for (i = 0; i < varNum; i++) {
				System.out.println("store temp " + (funcReg) + " "
						+ (4 * (i + 1)) + " " + curr.var.getVar(i));
			}

			// to return resreg
			if (curr == table) {
				System.out.println("mov temp " + resReg + " temp " + classReg);
			}
			// put class pointer(reg) into memory
			else {
				System.out.println("store temp " + classStoreReg + " 0 "
						+ "temp " + classReg);
			}
			// copy father-reg
			if (curr.father != null) {
				System.out.println("mov temp " + classStoreReg + " plus "
						+ "temp " + classReg + " " + (4 * (classSize - 1)));
				curr = curr.father;
			}
			// father is null
			else {
				System.out.println("hstore temp " + classReg + " "
						+ (4 * (classSize - 1)) + " 0 ");
				break;
			}
		}
		System.out.println("return temp " + resReg);
		System.out.println("end");
		return null;
	}

	/**
	 * f0 -> "!" f1 -> Expression()
	 */
	public Integer visit(NotExpression n,tab s) {
		System.out.println("minus 1 ");
		n.f1.accept(this,s);
		return null;
	}

	/**
	 * f0 -> "(" f1 -> Expression() f2 -> ")"
	 */
	public Integer visit(BracketExpression n,tab s) {
		n.f1.accept(this,s);
		return null;
	}

}
