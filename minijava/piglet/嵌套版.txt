//
// Generated by JTB 1.3.2
//

package visitor;

import syntaxtree.*;
import types.*;
import java.util.*;
import temp.*;
/*position to print*/

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order. Your visitors may extend this class.
 */
public class PigletVisit extends GJDepthFirst<Integer,tab>{
	//
	// Auto class visitors--probably don't need to be overridden.
	//
	//
	// User-generated visitor methods below
	//
	TypeTable types;
	ClassTable table;
	Function func;
	int reg;// current register number
	int label;
	int error;
	int noerror;
	/*the son-tab will be casted to its father class b*/
	void typeCast(String a,String b,int castReg,tab s)
	{
		if(a.equals(b)) return;/*no need for casting*/
		ClassTable _table = types.getClass(a);
		ClassTable _fatherTable=types.getClass(b);
		while (_table!= _fatherTable) {
			Println(("hload temp " + (castReg) + " temp "+ (castReg)+" "+(4*(_table.var.getSize()+1))),s);
			_table=_table.father;
		}
	}
	void Print(String s)
	{
		System.out.print(s);
	}
	void Println(String s,tab n)
	{
		System.out.println();
		for(int i=0;i<n.t;i++)
		System.out.print(" ");
		System.out.print(s);
	}
	/**
	 * f0 -> MainClass() f1 -> ( TypeDeclaration() )* f2 -> <EOF>
	 */
	public Integer visit(Goal n,tab s) {
		n.f0.accept(this,s);
		n.f1.accept(this,s);
		return null;
	}

	public PigletVisit(TypeTable types) {
		this.types = types;
	}

	/**
	 * f0 -> "class" f1 -> Identifier() f2 -> "{" f3 -> "public" f4 -> "static"
	 * f5 -> "void" f6 -> "main" f7 -> "(" f8 -> "String" f9 -> "[" f10 -> "]"
	 * f11 -> Identifier() f12 -> ")" f13 -> "{" f14 -> PrintStatement() f15 ->
	 * "}" f16 -> "}"
	 */
	public Integer visit(MainClass n,tab s) {
		reg=1;
		label=noerror=error=0;
		Println(("main"),s);
		n.f14.accept(this,s);
		Println(("end"),s);
		return null;
	}

	/**
	 * f0 -> ClassDeclaration() | ClassExtendsDeclaration()
	 */
	public Integer visit(TypeDeclaration n,tab s) {
		n.f0.accept(this,s);
		return null;
	}

	/**
	 * f0 -> "class" f1 -> Identifier() f2 -> "{" f3 -> ( VarDeclaration() )* f4
	 * -> ( MethodDeclaration() )* f5 -> "}"
	 */
	public Integer visit(ClassDeclaration n,tab s) {
		System.out.println();
		table = types.getClass(n.f1.f0.tokenImage);
		n.f4.accept(this,s);
		return null;
	}

	/**
	 * f0 -> "class" f1 -> Identifier() f2 -> "extends" f3 -> Identifier() f4 ->
	 * "{" f5 -> ( VarDeclaration() )* f6 -> ( MethodDeclaration() )* f7 -> "}"
	 */
	public Integer visit(ClassExtendsDeclaration n,tab s) {
		table = types.getClass(n.f1.f0.tokenImage);
		n.f6.accept(this,s);
		return null;
	}

	/**
	 * f0 -> "public" f1 -> Type() f2 -> Identifier() f3 -> "(" f4 -> (
	 * FormalParameterList() )? f5 -> ")" f6 -> "{" f7 -> ( VarDeclaration() )*
	 * f8 -> ( Statement() )* f9 -> "return" f10 -> Expression() f11 -> ";" f12
	 * -> "}"
	 */
	public Integer visit(MethodDeclaration n,tab s) {
		func = table.getFunc(n.f2.f0.tokenImage);
		int index = 0;
		int size = func.body.getSize();
		int parasize = func.para.size();
		// initialize marks in the process
		error = 0;
		noerror = 0;
		label = 0;
		System.out.println();
		/*the name of a process*/
		Println((table.name + "_" + func.name + " [" + (parasize + 1)+ "]"),s);
		Println(("begin"),s);
		/*initialize vars declared in function*/
		for (index = parasize+1; index <= size; index++) {
			Println(("mov temp " + index + " 0"),s.add());
		}
		reg=size+1;
		/*handle statements*/
		n.f8.accept(this,s.add());
		Println("return ",s.add());
		n.f10.accept(this,s.add(2));
		Println(("end"),s);
		return null;
	}

	/**
	 * f0 -> Block() | AssignmentStatement() | ArrayAssignmentStatement() |
	 * IfStatement() | WhileStatement() | PrintStatement()
	 */
	public Integer visit(Statement n,tab s) {
		n.f0.accept(this,s);
		return null;
	}

	/**
	 * f0 -> "{" f1 -> ( Statement() )* f2 -> "}"
	 */
	public Integer visit(Block n,tab s) {
		n.f1.accept(this,s);
		return null;
	}

	/**
	 * need to judge in which scope  f0 -> Identifier() f1 -> "=" f2
	 * -> Expression() f3 -> ";"
	 */
	public Integer visit(AssignmentStatement n,tab s) {
		String name = n.f0.f0.tokenImage;
		Integer resReg=n.f2.accept(this,s.add());
		/*declared in function,and stored in register from 1 to n*/
		if(func.declaredInFunc(name))
			Println("mov temp " 
					+ (func.getNum(name)) + " temp "+resReg,s);
		/*declared in class,and stored in memory from temp0 4 to 4*n*/
		else
		{
			Println("hstore temp 0 "
				+ (func.getNum(name) * 4) + " ",s);
		}
		
		return null;
	}

	/**
	 * f0 -> Identifier() f1 -> "[" f2 -> Expression() f3 -> "]" f4 -> "=" f5 ->
	 * Expression() f6 -> ";"
	 */
	public Integer visit(ArrayAssignmentStatement n,tab s) {
		int arrayReg=(++reg);
		// assign a var stored in function
		Println(("mov temp " + (arrayReg) +" "),s);
		n.f0.accept(this,s.add());
		/**/
		// prevent an uninitialized array
		//if arrayReg<=0 error
		Println(("cjump lt temp " + (arrayReg) + " 1 noerror" + (++noerror)),s);
		Println(("error"),s); 
		Println(("noerror"+noerror+" noop"),s); 
		
		// the index will be calculated and stored in reg+1
		int indexReg=(++reg);
		Println(("mov temp " + (indexReg)+" "),s);
		n.f2.accept(this,s.add());
		Println(("mov temp " + (indexReg) + " plus 1 temp " + (indexReg)),s);
		// prevent a beyond array
		int sizeReg=(++reg);
		Println(("hload temp " + (sizeReg) + " temp " + (arrayReg) + " 0"),s);
		// if indexReg<=sizeReg,right
		Println(("cjump lt temp " + (sizeReg) + " temp " + (indexReg)+ " noerror" + (++noerror)),s);
		Println(("error"),s); 
		Println(("noerror"+noerror+" noop"),s); 
		// 	index=4*indexReg
		Println(("mov temp " + (indexReg) + " times 4 temp " + (indexReg)),s);
		//	arrayReg=array element pointer
		Println(("mov temp " + (arrayReg) + " plus temp " + (arrayReg)+" temp "+(indexReg)+" "),s);
		Println(("hstore temp " + (arrayReg) +" 0 "),s);
		n.f5.accept(this,s);
		return null;
	}

	/**
	 * f0 -> "if" f1 -> "(" f2 -> Expression() f3 -> ")" f4 -> Statement() f5 ->
	 * "else" f6 -> Statement()
	 */
	public Integer visit(IfStatement n,tab s) {
		n.outlabel = (++label);
		n.iflabel = (++label);
		n.elselabel = (++label);
		int ifReg=(++reg);
		Println(("mov temp " + (ifReg)+" "),s);
		n.f2.accept(this,s.add());
		/*if 0>=ifReg,goto else*/
		Println(("cjump lt 0 temp " + (ifReg)+" elselabel" + (n.elselabel)),s);
		Println(("iflabel" + (n.iflabel) + " NOOP"),s);
		n.f4.accept(this,s);
		Println(("jump label" + (n.outlabel)),s);
		Println(("elselabel" + (n.elselabel) + " NOOP"),s);
		n.f6.accept(this,s);
		Println(("outlabel" + (n.outlabel) + " NOOP"),s);
		return null;
	}

	/**
	 * f0 -> "while" f1 -> "(" f2 -> Expression() f3 -> ")" f4 -> Statement()
	 */
	public Integer visit(WhileStatement n,tab s) {
		n.iflabel = (++label);
		n.outlabel = (++label);
		int ifReg=(++reg);
		Println(("whilelabel" + (n.iflabel) + " NOOP"),s);
		Println(("mov temp " + (ifReg)+" "),s);
		n.f2.accept(this,s.add());
		// if 0>=ifReg ,break
		Println(("cjump lt 0 temp " +(ifReg)+" outlabel" + (n.outlabel)),s);
		n.f4.accept(this,s);
		Println(("jump whilelabel" + n.iflabel),s);
		Println(("outlabel" + (n.outlabel) + " NOOP"),s);
		return null;
	}

	/**
	 * f0 -> "System.out.println" f1 -> "(" f2 -> Expression() f3 -> ")" f4 ->
	 * ";"
	 */
	public Integer visit(PrintStatement n,tab s) {
		Println(("print "),s);
		n.f2.accept(this,s.add());
		return null;
	}

	/**
	 * f0 -> AndExpression() | CompareExpression() | PlusExpression() |
	 * MinusExpression() | TimesExpression() | ArrayLookup() | ArrayLength() |
	 * MessageSend() | PrimaryExpression()
	 */
	public Integer visit(Expression n,tab s) {
		if(n.cast!=false)
		{
			//System.out.println();
			Println(("begin"),s);
			System.out.println();;;;
			Println(("mov temp "+(++reg)+" "),s.add());
			n.f0.accept(this,s.add(2));
			typeCast(n.preType.TypeName,n.castType.TypeName,reg,s.add());
			Println(("return temp "+reg),s.add());
			Println(("end"),s);
		}
		else n.f0.accept(this,s);
		return null;
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "&&" f2 -> PrimaryExpression()
	 */
	public Integer visit(AndExpression n,tab s) {
		int outlabel = ++label;
		int resReg=(++reg);
		Println(("begin"),s);
		Println(("mov temp " + (resReg)+" "),s.add());
		n.f0.accept(this,s.add(2));
		/*if 0>=resReg goto outLabel*/
		Println(("cjump lt 0 temp " + (resReg) +" andlabel" + (outlabel)),s.add());
		Println(("mov temp " + (resReg)+" "),s.add());
		n.f2.accept(this,s.add(2));
		Println(("andlabel" + (outlabel) + " NOOP"),s.add());
		Println(("return temp " + (resReg)),s.add());
		Println(("end"),s);
		return null;
	}

/**
    * f0 -> PrimaryExpression()
    * f1 -> "<"
    * f2 -> PrimaryExpression()
    */
	public Integer visit(CompareExpression n,tab s) {
		Print(" lt ");
		n.f0.accept(this,s.add());
		n.f2.accept(this,s.add());
		return null;
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "+" f2 -> PrimaryExpression()
	 */
	public Integer visit(PlusExpression n,tab s) {
		Print(" plus ");
		n.f0.accept(this,s.add());
		n.f2.accept(this,s.add());
		return null;
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "-" f2 -> PrimaryExpression()
	 */
	public Integer visit(MinusExpression n,tab s) {
		Print(" minus ");
		n.f0.accept(this,s.add());
		n.f2.accept(this,s.add());
		return null;
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "*" f2 -> PrimaryExpression()
	 */
	public Integer visit(TimesExpression n,tab s) {
		Print(" times ");
		n.f0.accept(this,s.add());
		n.f2.accept(this,s.add());
		return null;
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "[" f2 -> PrimaryExpression() f3 -> "]"
	 */
	public Integer visit(ArrayLookup n,tab s) {
		// prevent array problems???
		int arrayReg=(++reg); 
		//System.out.println("");
		Println(("begin"),s);
		Println(("mov temp " + (arrayReg)+" "),s.add());
		n.f0.accept(this,s.add(2));
		/*prevent uninitialized visit*/
		/*if arrayReg>=1 goto no-error*/
		Println(("cjump lt temp "+ arrayReg+ " 1 noerror"+(++noerror)),s.add());
		Println(("error"),s.add());
		Println(("noerror"+noerror+" noop"),s.add());
		
		int indexReg =++reg;
		Println(("mov temp " + (indexReg)+" "),s.add());
		n.f2.accept(this,s.add(2));
		Println(("mov temp " + (indexReg)+" plus temp "+(indexReg)+" 1"),s.add());
		int sizeReg =++reg;
		Println(("hload temp " + (sizeReg)+" temp "+(arrayReg)+" 0"),s.add());
		/*prevent out of range*/
		/*if sizeReg>=indexReg ,goto no-error*/
		Println(("cjump lt  temp "+ sizeReg+ " temp "+indexReg+" noerror"+(++noerror)),s.add());
		Println(("error"),s.add());
		Println(("noerror"+noerror+" noop"),s.add());
		
		Println(("mov temp " + (indexReg)+ " times 4 temp "+(indexReg)),s.add());
		/*array[index] return a pointer in fact*/
		Println(("mov temp " + (arrayReg)+" plus temp "+(arrayReg)+" temp "+indexReg),s.add());
		Println(("return temp " + arrayReg),s.add());
		Println(("end"),s);
		return null;
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "." f2 -> "length"
	 */
	public Integer visit(ArrayLength n,tab s) {
		//System.out.println("");
		Println(("begin"),s);
		int arrayReg = ++reg;
		Println(("mov temp " + (arrayReg)+" "),s.add());
		n.f0.accept(this,s.add(2));
		/*if the array is uninitialized*/
		Println(("cjump lt temp " + (arrayReg) + " 1 noerror" + (++noerror)),s.add());
		Println(("error"),s.add());
		Println(("noerror"+noerror+" noop"),s.add());
		
		Println(("hload temp " + (arrayReg) + " temp " + (arrayReg) + " 0"),s.add());
		Println(("return temp " + (arrayReg)),s.add());
		Println(("end"),s);
		return null;
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "." f2 -> Identifier() f3 -> "(" f4 -> (
	 * ExpressionList() )? f5 -> ")"
	 */
	public Integer visit(MessageSend n,tab s) {
		int classReg = (++reg);// duotai!!!!
		int functableReg = (++reg);
		int funcReg = (++reg);
		String name=n.f2.f0.tokenImage;
		Println(("call"),s);
		Println("begin",s.add());////////
		Println(("mov temp " + (classReg)+" "),s.add(2));
		n.f0.accept(this,s.add(3));
		ClassTable _table = types.getClass(n.className);
		ClassTable _castTable=_table;
		while (_castTable.func.get(name) == null) {
			_castTable=_castTable.father;
		}
		typeCast(_table.name,_castTable.name,classReg,s.add(2));
		/*prevent a uninitialized call*/
		Println(("cjump lt temp "+classReg+" 1 noerror"+(++noerror)),s.add(2));
		Println(("error"),s.add(2));
		Println(("noerror"+(noerror)+" noop"),s.add(2));
		/*store function*/
		Println(("hload temp " + (functableReg) + " temp "+(classReg)+" 0"),s.add(2));
		Println(("hload temp " + (funcReg) + " temp "+(functableReg)+" "+(4*_table.func.getNum(name))),s.add(2));
		Println(("return temp "+funcReg),s.add(2));//func-reg store the address of process 
		Println(("end"),s.add());
		Println("( temp "+classReg+" ",s.add());
		n.f4.accept(this,s.add());
		Println((" ) "),s.add());
		return null;
	}

	/**
	 * f0 -> Expression() f1 -> ( ExpressionRest() )*
	 */
	public Integer visit(ExpressionList n,tab s) {
		n.f0.accept(this,s);
		System.out.print(" ");
		n.f1.accept(this,s);
		return null;
	}

	/**
	 * f0 -> "," f1 -> Expression()
	 */
	public Integer visit(ExpressionRest n,tab s) {
		n.f1.accept(this,s);
		System.out.print(" ");
		return null;
	}

	/**
	 * f0 -> IntegerLiteral() | TrueLiteral() | FalseLiteral() | Identifier() |
	 * ThisExpression() | ArrayAllocationExpression() | AllocationExpression() |
	 * NotExpression() | BracketExpression()
	 */
	public Integer visit(PrimaryExpression n,tab s) {
		n.f0.accept(this,s);
		return null;
	}

	/**
	 * f0 -> <INTEGER_LITERAL>
	 */
	public Integer visit(IntegerLiteral n,tab s) {
		System.out.print(n.f0.tokenImage);
		return null;
	}

	/**
	 * f0 -> "true"
	 */
	public Integer visit(TrueLiteral n,tab s) {
		System.out.print("1");
		return null;
	}

	/**
	 * f0 -> "false"
	 */
	public Integer visit(FalseLiteral n,tab s) {
		System.out.print("0");
		return null;
	}

	/**
	 * f0 -> <IDENTIFIER>
	 */
	public Integer visit(Identifier n,tab s) {
		String name=n.f0.tokenImage;
		int resReg=(++reg);
		if (func.declaredInFunc(name)) 
		{
			Print(" temp " + (func.getNum(name)));
		}
		else {
			//System.out.println("");
			Println(("begin"),s);
			Println(("hload temp " + (resReg) + " temp 0 " + (func.getNum(name) * 4) ),s.add());
			Println(("return temp "+resReg),s.add());
			Println(("end"),s);
		}
		return null;
	}

	/**
	 * f0 -> "this"
	 */
	public Integer visit(ThisExpression n,tab s) {
		System.out.print(" temp 0");
		return null;
	}

	/**
	 * f0 -> "new" f1 -> "int" f2 -> "[" f3 -> Expression() f4 -> "]"
	 */
	public Integer visit(ArrayAllocationExpression n,tab s) {
		int sizeReg = (++reg);
		int resReg = (++reg);
		int indexReg = (++reg);
		int storeReg =(++reg);
		//System.out.println("");
		Println(("begin"),s);
		Println(("mov temp " + (sizeReg)+" "),s.add());
		n.f3.accept(this,s.add(2));
		/*prevent f3<0*/
		/*f3>=0 is legal*/
		Println(("cjump lt temp " + (sizeReg) + " 0 noerror"+ (++noerror)),s.add());
		Println(("error"),s.add());
		Println(("noerror"+noerror+" noop"),s.add());
		/*if size==0 , there will be one word,just size itself*/
		Println(("mov temp " + (sizeReg)+" plus 1 temp "+sizeReg),s.add());
		/*sizeReg here is the real number of words stored in memory*/
		Println(("mov temp " + (resReg) + " hallocate times 4 temp "+ sizeReg),s.add());
		/*sizeReg-=1,store array-size*/
		Println(("mov temp " + (sizeReg)+" minus temp "+sizeReg+" 1"),s.add());
		Println(("store temp " + (resReg)+" 0 temp "+sizeReg),s.add());
		
		/*initialize the array elements*/
		/*sizeReg+=1*/
		Println(("mov temp " + (sizeReg)+" plus 1 temp "+sizeReg),s.add());
		/*index=1,if index>=sizeReg goto out-label;index+=4.*/
		int whilelabel=(++label);
		int outlabel=(++label);
		Println(("mov temp " + (indexReg)+" 1"),s.add());
		Println(("mov temp " + (storeReg)+" plus temp "+resReg+" 4"),s.add());
		
		Println(("whilelabel"+(whilelabel)+" noop"),s.add());
		Println(("cjump temp "+indexReg+" temp " + (sizeReg)+" outlabel"+(outlabel)),s.add());
		Println(("store temp " + (storeReg)+" 0 0 "),s.add());
		Println(("mov temp " + (indexReg)+" plus temp "+indexReg+" 1"),s.add());
		Println(("mov temp " + (storeReg)+" plus temp "+storeReg+" 4"),s.add());
		Println(("cjump whilelabel"+(whilelabel)),s.add());
		Println(("outlabel"+(outlabel)+" noop"),s.add());
		Println(("return temp " + resReg),s.add());
		Println(("end"),s);
		return null;
	}

	/*get process*/
	String getProcess(ClassTable a, int i) {
		return a.name + "_" + a.func.getFunc(i);
	}

	/**
	 * f0 -> "new" f1 -> Identifier() f2 -> "(" f3 -> ")"
	 */
	public Integer visit(AllocationExpression n,tab s) {
		//System.out.println("");
		Println(("begin"),s);
		table = types.getClass(n.f1.f0.tokenImage);
		ClassTable curr = table;
		int i;
		int resReg = (++reg);
		int classReg = (++reg);
		int funcReg = (++reg);
		int classStoreReg = (++reg);

		int funcNum = 0;
		int varNum = 0;
		int classSize = 0;
		int fatherSize = 0;
		while (curr != null) {
			funcNum = curr.func.getSize();
			varNum = curr.var.getSize();
			classSize = varNum + 2;
			Println(("mov temp " + (classReg) + " hallocate "+ (4 * (classSize))),s.add());
			Println(("mov temp " + (funcReg) + " hallocate "+ (4 * funcNum)),s.add());
			// store functions
			for (i = 0; i < funcNum; i++) {
				Println(("hstore temp " + (funcReg) + " " + (4 * i)+ " " + getProcess(curr, i)),s.add());
			}
			Println(("hstore temp " + (classReg) + " 0 " + "temp "+ (funcReg)),s.add());

			// initialize vars
			for (i = 0; i < varNum; i++) {
				Println(("hstore temp " + (classReg) + " "+ (4 * (i + 1)) + " 0"),s.add());
			}

			// to return resreg
			if (curr == table) {
				Println(("mov temp " + resReg + " temp " + classReg),s.add());
			}
			// put class pointer(reg) into memory
			else {
				Println(("hstore temp " + classStoreReg + " 0 "+ "temp " + classReg),s.add());
			}
			// copy father-reg
			if (curr.father != null) {
				Println(("mov temp " + classStoreReg + " plus "+ "temp " + classReg + " " + (4 * (classSize - 1))),s.add());
				curr = curr.father;
			}
			// father is null
			else {
				Println(("hstore temp " + classReg + " "+ (4 * (classSize - 1)) + " 0 "),s.add());
				break;
			}
		}
		Println(("return temp " + resReg),s.add());
		Println(("end"),s);
		return null;
	}

	/**
	 * f0 -> "!" f1 -> Expression()
	 */
	public Integer visit(NotExpression n,tab s) {
		System.out.print("minus 1 ");
		n.f1.accept(this,s.add());
		return null;
	}

	/**
	 * f0 -> "(" f1 -> Expression() f2 -> ")"
	 */
	public Integer visit(BracketExpression n,tab s) {
		n.f1.accept(this,s);
		return null;
	}

}
